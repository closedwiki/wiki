#!/usr/bin/perl -w
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at 
# http://www.gnu.org/copyleft/gpl.html
#
# Configuration script for TWiki. Once you have a basic webserver
# configuration that lets you access this script, the rest of the
# configuration process is done from here. This script replaces
# the old "testenv" script.
#
# The script works by accepting values into a CGI form, and then
# submitting those values back to itself with a parameter (update)
# set to 1. This causes it to write config changes to LocalSite.cfg.
# Note that changes are only written if there is a real change in the
# value.
#
# The values available to configuration are determined by parsing
# TWiki.cfg. Special full-line comments guide the parse:
# Any comment of the form
######## Some text #########
# is taken as a H2 heading, and following comments are dragged in too.
# Comments of the form
# **TYPE opts**
# where TYPE is one of URL, PATH, URLPATH, BOOLEAN, STRING, REGEX, SELECT
# are used to indicate that a following cfg var is configurable through
# the interface. All intermediate comments are taken as documentation for
# the value.
#
package TWiki;

# BASIC checks. Without these, nothing works.

use strict;
my $setlibAvail;
my $brokenTWikiCfg;
my $brokenTWikiCfgError;
my $brokenLocalSiteError;
my %cfg; # TWiki config
my $OS;
my $detailedOS;
my $cygwinRcsVerNum;
my $perlverRequired = 5.00503;		# Oldest supported version of Perl
my $perlverRequiredString = '5.005_03';
my $perlverRecommended = '5.6.1';
my $perlVerPreferred = 5.006;	# 5.6 or higher has [:lower:] etc
my $ActivePerlRecommendedBuild = 631;	# Fixes PERL5SHELL bugs
my $GUESSED = <<'HERE';
I guessed this setting. You are advised to confirm this setting (and any other guessed settings) and 'Save' before changing any other settings.
HERE

# CGI.pm version, on some platforms - actually need CGI 2.93 for mod_perl
# 2.0 and CGI 2.90 for Cygwin Perl 5.8.0.  See 
# http://perl.apache.org/products/apache-modules.html#Porting_CPAN_modules_to_mod_perl_2_0_Status
my $cgiModVerRecommended = '2.93';	

# Recommended mod_perl version if using mod_perl 2.0 (see Support.RegistryCookerBadFileDescriptor)
my $modPerlVersionRecommended = '1.99_12';	

my $rcsverRequired = 5.7;

my $update_enabled = 0;
my $path_to_localsite_cfg = _findFileOnPath('LocalSite.cfg');
my $errors = 0;
my $toterrors = 0;
my $warnings = 0;
my $totwarnings = 0;

use CGI qw( :any );
my $query = new CGI;
my $url = $query->url();
my $action = $query->param('action') || '';
my $perlvernum = $];
my $perlver;
my $perlverMsg;

use vars qw( $perltype $TRUE $FALSE );

BEGIN {
    $TRUE = 1;
    $FALSE = 0;
    # Set default current working directory
    if( $ENV{"SCRIPT_FILENAME"} && $ENV{"SCRIPT_FILENAME"} =~ /^(.+)\/[^\/]+$/ ) {
        chdir $1;
    }
}

# Required for testenv to work
my %basicMods =
  (
   'CGI'       => "basic TWiki",
   'CGI::Carp' => "basic TWiki"
  );

my %requiredMods =
  (
   'File::Copy' => 'basic TWiki',
   'File::Spec' => 'basic TWiki',
   'FileHandle' => 'basic TWiki',
  );

# Required on non-Unix platforms (mainly Windows)
my %requiredModsNonUnix =
  (
   'Digest::SHA1' => "register script",
   'MIME::Base64' => "register script",
   'Net::SMTP'    => "registration emails and mailnotify",
  );

# Optional modules on all platforms
my %optionalMods =
  (
   'MIME::Base64'     => "HTTP Authentication to proxies (CPAN)",
   'POSIX'            => "I18N (core module) and Security",
   'Digest::MD5'      => "MD5 encoded passwords",
   'Encode'           => "I18N conversions (core module in Perl 5.8)",
   'Unicode::MapUTF8' => "I18N conversions (CPAN)",
   'Unicode::Map'     => "I18N conversions (CPAN)",
   'Unicode::Map8'    => "I18N conversions (CPAN)",
   'Jcode'            => "I18N conversions (CPAN)",
  );

sub _makeAnchor {
    my $str = shift;

    $str =~ s/\s(\w)/uc($1)/ge;
    $str =~ s/\W//g;
    return $str;
}

sub _promptSTRING {
    my( $id, $opts, $value, $keys ) = @_;
    my $size = 60;
    if( $opts =~ /\s(\d+)\s/ ) {
        $size = $1;
    }
    return CGI::textfield( -name => $id, -size=>$size, -default=>$value );
}

sub _promptURL {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptURLPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptBOOLEAN {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::checkbox( -name => $id, -checked => ( $value ? 1 : 0),
                          -value => 1, -label => '' );
}

sub _promptREGEX {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptCOMMAND {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptNUMBER {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>20, -default=>$value );
}

sub _promptOCTAL {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>20,
                           -default=>sprintf('0%o',$value) );
}

sub _promptSELECT {
    my( $id, $opts, $value, $keys ) = @_;
    $opts =~ s/^\s+//;
    $opts =~ s/\s.*$//;
    my $sopts = '';
    foreach my $opt (split( /\s*,\s*/, $opts)) {
        if( $opt eq $value ) {
            $sopts .= '<option selected="selected">'.$opt.'</option>';
        } else {
            $sopts .= '<option>'.$opt.'</option>';
        }
    }
    return CGI::Select({ name => $id, size=>1, default=>$value }, $sopts);
}

sub _checkBinDir {
    my $dir = $ENV{SCRIPT_FILENAME} || '.';
    $dir =~ s(/+configure[^/]*$)();
    my $ext = $TWiki::cfg{ScriptSuffix} || '';
    my $errs = '';
    opendir(D, $dir) or return ERROR("Can't open $dir for read");
    foreach my $script (grep { !/(^\.|\.cfg|\.txt)/ } readdir D) {
        next if( $ext && $script !~ /\.$ext$/ );
        if( !-x "$dir/$script" ) {
            $errs .= WARN($script . ' is not executable');
        }
    }
    closedir(D);
    return $dir.'<br />'.$errs;
}

sub _checkDefaultUrlHost {
    my $keys = shift;

    if( $TWiki::cfg{DefaultUrlHost} ) {
        my $host = $ENV{HTTP_HOST};
        if( $host && $TWiki::cfg{DefaultUrlHost} !~ /$host/ ) {
            return WARN('Current setting does not match HTTP_HOST ',
                        $ENV{HTTP_HOST});
        }
    } else {
        my $protocol = $url || 'http://'.$ENV{HTTP_HOST};
        $protocol =~ s(^(.*?://.*?)/.*$)($1);
        $TWiki::cfg{DefaultUrlHost} = $protocol;
        return WARN($GUESSED);
    }
    return '';
}

sub _checkScriptUrlPath {
    # Check Script URL Path against REQUEST_URI
    my $n;
    my $val = $TWiki::cfg{ScriptUrlPath};
    my $guess = $ENV{REQUEST_URI} || $ENV{SCRIPT_NAME} || '';
    $guess =~ s(/+configure[^/]*$)();

    if( $val ) {
        unless( $guess ) {
            return WARN(<<HERE
This web server does not set REQUEST_URI or SCRIPT_NAME
so it isn't possible to check the correctness of this setting.
HERE
                       );
        };
        if ( $guess !~ /^$val/ ) {
            return WARN('I expected this to look like "'.$guess.'"');
        }
    } else {
        unless( $guess ) {
            return WARN(<<HERE
This web server does not set REQUEST_URI or SCRIPT_NAME
so it isn't possible to guess this setting.
HERE
                       );
        };
        $TWiki::cfg{ScriptUrlPath} = $guess;
        return WARN($GUESSED);
    }
    return '';
}

sub _checkPubUrlPath {
    unless( $TWiki::cfg{PubUrlPath} ) {
        my $guess = $TWiki::cfg{ScriptUrlPath};
        $guess =~ s/bin$/pub/;
        $TWiki::cfg{PubUrlPath} = $guess;
        return WARN($GUESSED);
    }
    return 'This is not set correctly if the link below is broken:<br />'.
      '<a href="'.$TWiki::cfg{PubUrlPath}.'">click here</a>';
}

sub _findMajorDir {
    my( $cfg, $dir ) = @_;
    return '' if( $TWiki::cfg{$cfg} );
    my $guess = $ENV{SCRIPT_FILENAME};
    unless( $guess ) {
        return WARN("This web server does not set SCRIPT_FILENAME so I can't guess a value for this");
    }
    $guess =~ s(bin/*configure$)();
    $guess .= $dir;
    $TWiki::cfg{$cfg} = $guess;
    return WARN($GUESSED);
}

sub _checkPubDir {
    my $e = _findMajorDir('PubDir', 'pub');
    my $e2 = _checkTreePerms( $TWiki::cfg{PubDir}, 'rw' );
    $e = WARN($e2) if $e2;
    return $e;
}

sub _checkTemplateDir {
    my $e = _findMajorDir('TemplateDir', 'templates');
    my $e2 = _checkTreePerms( $TWiki::cfg{TemplateDir}, 'r' );
    $e .= ERROR($e2) if $e2;
    return $e;
}

sub _checkDataDir {
    my $e = _findMajorDir('DataDir', 'data');
    my $e2 = _checkTreePerms( $TWiki::cfg{DataDir}, "r" );
    $e2 = _checkTreePerms( $TWiki::cfg{DataDir}, "w", qr/\.txt$/ )
      unless $e2;
    $e .= WARN($e2) if $e2;
    return $e;
}

sub _checkMailProgram {
    eval "use Net::SMTP";
    my $n;
    if ($@) {
        $n = "Net::SMTP is <b>not</b> installed in this environment. ";
        my $val = $TWiki::cfg{MailProgram} || '';
        $val =~ s/\s.*$//g;
        if( ! ( -e $val ) ) {
            return WARN("<tt>$val</tt> was not found. Check the path.");
        }
    } else {
        $n = 'Net::SMTP is installed in this environment, so this setting will <b>not</b> be used.';
    }
    return $n;
}

sub _checkLogFileName {
    my $logFile = $TWiki::cfg{LogFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkConfigurationLogName {
    my $logFile = $TWiki::cfg{ConfigurationLogName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkWarningFileName {
    my $logFile = $TWiki::cfg{WarningFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkDebugFileName {
    my $logFile = $TWiki::cfg{DebugFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkMimeTypesFileName {
    my $e = _checkTreePerms($TWiki::cfg{MimeTypesFileName}, 'r');
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkHtpasswd_FileName {
    my $e = _checkTreePerms($TWiki::cfg{Htpasswd}{FileName}, 'r');
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkRemoteUserFileName {
    my $file = $TWiki::cfg{RemoteUserFileName};;
    my $e = _checkCanCreateFile( $file );
    $e = WARN($e) if $e;
    return $e;
}

sub _checkRegistrationApprovals {
    my $file = $TWiki::cfg{RegistrationApprovals};
    my $e = _checkTreePerms( $file, 'rw' );
    $e = WARN($e) if $e;
    return $e;
}

sub _checkUseLocale {
    my $on = $TWiki::cfg{UseLocale};
    my $n = '';
    if( $on && $TWiki::cfg{OS} eq 'WINDOWS' ) {
        # Warn re known broken locale setup
        $n .= WARN(<<HERE
Using Perl on Windows, which may have missing or incorrect locales (in Cygwin
or ActiveState Perl, respectively) - turning off {LocaleRegexes} is
recommended unless you know your version of Perl has working locale support.
HERE
                  );
    }

	# Warn against Perl 5.6 or lower for UTF-8
	if ( $on && $perlvernum < 5.008 ) {
        $n .= WARN("Perl 5.8 is required if you are using TWiki's",
                   "experimental UTF-8 support\n");
    }

    # Check for 'useperlio' in Config on Perl 5.8 or higher - required
    # for use of ':utf8' layer.
    if ( $on && $perlvernum >= 5.008 and 
         not ( exists $Config::Config{useperlio} and
               $Config::Config{useperlio} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled to use PerlIO",
                   "by default ('useperlio' not set in Config.pm, see",
                   "<i>Perl's Unicode Model</i> in 'perldoc perluniintro')",
                   "- re-compilation of Perl will be required before it",
                   "can be used to enable TWiki's experimental UTF-8",
                   "support.");
    }

    # Check for d_setlocale in Config (same as 'perl -V:d_setlocale')
    eval "use Config";
    if ( $on && !( exists $Config::Config{d_setlocale} &&
                   $Config::Config{d_setlocale} eq 'define' ) ) {
        $n .= WARN(<<HERE
This version of Perl was not compiled with locale support ('d_setlocale' not
set in Config.pm) - re-compilation of Perl will be required before it can be
used to support TWiki internationalisation.
HERE
                  );
    }
    return $n;
}

sub _checkUpperNational {
    if( $perlvernum < $perlVerPreferred || 1) {
        # Locales are off/broken, or using pre-5.6 Perl, so have to 
        # explicitly list the accented characters (but not if using UTF-8)
        my $forUpperNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;

        if ($forUpperNat) {
            return WARN( <<HERE
The following upper case accented characters have been found in this locale
and should be considered for use in this parameter:
<strong>$forUpperNat</strong>
HERE
                       );
        }
    }
    return '';
}

sub _checkLowerNational {
    if( $perlvernum < $perlVerPreferred || 1) {
        # Locales are off/broken, or using pre-5.6 Perl, so have to 
        # explicitly list the accented characters (but not if using UTF-8)
        my $forLowerNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;

        if ($forLowerNat) {
            return WARN( <<HERE
The following lower case accented characters have been found in this locale
and should be considered for use in this parameter:
<strong>$forLowerNat</strong>
HERE
                       );
        }
    }
    return '';
}

sub _checkSiteLocale {
    my $locale = $TWiki::cfg{SiteLocale};
    # Try to see if required locale was correctly set earlier
    my $currentLocale = setlocale(&LC_CTYPE);
    if ( $currentLocale ne $locale ) {
        return WARN(<<HERE
Unable to set locale to '$locale'. The actual locale is '$currentLocale'
- please test your locale settings. This warning can be ignored if you are
not planning to use locales (e.g. your site uses English only) - or you can
set  <strong>SiteLocale</strong> to <code>C</code>, which should always work.
HERE
                   );
    }
    return '';
}

# Since Windows (without Cygwin) makes it hard to capture stderr
# ('2>&1' works only on Win2000 or higher), and Windows will usually have
# GNU tools in any case (installed for TWiki since there's no built-in
# diff, grep, patch, etc), we only check for these tools on Unix/Linux 
# and Cygwin.  
sub checkGnuVersion {
    my $ok = 0;

    my ($progExecString, $progReadableName, $progUsage) = @_;        # Usage is 'used for...' string

    if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
        $progExecString =~ s/\s.*$//;
        my $diffOut = `$progExecString --version 2>&1` || "";
        my $notFound = ( $? == -1 );
        my $n;
        if( $notFound ) {
            $n = WARN("'$progReadableName' program was not found on the",
                      "current PATH.");
        } elsif ( $diffOut !~ /\bGNU\b/ ) {
            # Program found on path, complain if no GNU in version output
            $n = WARN("'$progReadableName' program was found on the PATH",
                      "but is not GNU $progReadableName - this may cause",
                      "problems. $diffOut");
        } else {
            $n = "GNU $progReadableName was found on the PATH -".
              " this is the recommended $progReadableName tool.";
            $ok = 1;
        }

        return _setting($progReadableName, $n,
                        NOTE("The '$progReadableName' command is $progUsage."));
    }

    return '';
}

sub _checkCanCreateFile {
    my $name = shift;
    if (-e $name) {
        return _checkTreePerms($name,'rw');
    }
    my $txt1 = "test 1 2 3";
    unlink $name if( -e $name );
    open( FILE, ">$name" ) ||
      return 'Could not create test file ', $name;
    print FILE $txt1;
    close( FILE);
    open( IN_FILE, "<$name" ) ||
      return 'Could not read test file ', $name;
    my $txt2 = <IN_FILE>;
    close( IN_FILE );
    unlink $name if( -e $name );
    unless ( $txt2 eq $txt1 ) {
        return 'Could not write and then read '.$name;
    }
    return '';
}

sub _checkTreePerms {
    my( $path, $perms, $filter ) = @_;

    return '' if( defined($filter) && $path !~ $filter && !-d $path);

    my $errs = '';

    return $path. ' cannot be found<br />' unless( -e $path );

    if( $perms =~ /r/ && !-r $path) {
        $errs .= ' readable';
    }

    if( $perms =~ /w/ && !-d $path && !-w $path) {
        $errs .= ' writable';
    }

    if( $perms =~ /x/ && !-x $path) {
        $errs .= ' executable';
    }

    return $path.' is not '.$errs.'<br />' if $errs;

    return '' unless -d $path;

    opendir(D, $path) ||
      return 'Directory '.$path.' is not readable.<br />';

    foreach my $e ( grep { !/^\./ } readdir( D )) {
        my $p = $path.'/'.$e;
        $errs .= _checkTreePerms( $p, $perms, $filter );
    }
    closedir(D);
    return $errs;
}

sub _checkScriptSuffix {
    # SMELL: should check to see what the extension on _this_ script
    # is, and generate a helpful message
    return '';
}

sub _checkStoreImpl {
    my $bad = '';
    if( $TWiki::cfg{StoreImpl} eq 'RcsWrap') {
        foreach my $key( %{$TWiki::cfg{RCS}} ) {
            if ( $key && $key =~ /Cmd$/ ) {
                my $proggy = $TWiki::cfg{RCS}{$key} || "";
                $proggy =~ s/\s.*$//;
                if( $proggy) {
                    my $version = `$proggy -V` || '';
                    $version =~ /(\d+(\.\d+)+)/;
                    $version = $1;
                    $proggy .= " (version $version)";
                    if( defined( $cygwinRcsVerNum )) {
                        $proggy .= " (Cygwin package <tt>rcs-$cygwinRcsVerNum</tt>)";
                    }
                    if( $proggy =~ /\/(rcs|rlog|rcsdiff|co)\b$/ &&
                        $version && $version < $rcsverRequired ) {
                        # RCS too old
                        $bad .= ERROR($proggy.' is too old, upgrade to version $rcsverRequired or higher.');
                    }
                }
            }
        }
    }

    if( $bad ) {
        $bad .= <<HERE;
TWiki will not work with this RCS setup. Either correct the setup, or
switch to RcsLite. To enable RCSLite you need to change the setting of
{StoreImpl} to 'RcsLite'.
HERE
        return $bad;
    }
    return '';
};

# a note
sub NOTE {
    return CGI::p({class=>"info"}, join("\n",@_));
}

# a warning
sub WARN {
    $warnings++;
    $totwarnings++;
    return CGI::div({class=>'warn'}, CGI::strong('Warning: ').join("\n",@_));
}

# an error
sub ERROR {
    $errors++;
    $toterrors++;
    return CGI::div({class=>'error'}, CGI::strong('Error: ').join("\n",@_));
}

sub _findFileOnPath {
    my $file = shift;
    $file =~ s(::)(/)g;

    foreach my $dir ( @INC ) {
        if( -e "$dir/$file" ) {
            return "$dir/$file";
        }
    }
    return undef;
}

# Generates the appropriate HTML for getting a value to configure the
# entry. The opts are additional parameters, and by convention may
# be a number (for a string length), a comma separated list of values
# (for a select) and may also have an M for mandatory. The actual
# input field is decided by the type, which is used to compose a function
# name by prepending _prompt.
#.
# The method also builds a function name by prepending _check to the
# field name, and calls it if it exists to perform additional checking
# for that specific field (see _checkDataDir as an example)
#
sub _checkAndBuildValueGrabber {
    my( $type, $opts, $desc, $keys) = @_;

    my $mandatory = ($opts =~ /\sM\s/);
    # field id
    my $id = $keys;
    $id =~ s/}{/_/g;
    $id =~ s/[{}\[\]]//g;
    my $anchor = CGI::a({name=>$id},'');
    print CGI::hidden(-name => 'TYPEOF:'.$id, -value=>$type);
    my $checker = '_check'.$id;
    if( defined &$checker ) {
        no strict 'refs';
        $desc .= &$checker();
        use strict 'refs';
    }

    my $prompter = '_prompt'.$type;
    my $value = eval '$TWiki::cfg'.$keys;
    no strict 'refs';
    $prompter = &$prompter($id, $opts, $value, $keys, $mandatory);
    my $class = $type;
    $class .= ' mandatory' if $mandatory;
    $prompter = CGI::span({class=>$class}, $prompter) if $mandatory;
    use strict 'refs';

    $desc = $anchor."\n".$desc;

    $keys = CGI::span({class=>'mandatory'}, $keys) if $mandatory;

    return _docBlock( $desc )._setting( $keys, $prompter );
}

sub setConfig {
    my ($path_to_localsite_cfg, $updates) = @_;
    my $txt = '';
    if( open(F, "<$path_to_localsite_cfg")) {
        undef $/;
        $txt = <F>;
        close(F);
    }

    foreach my $config ( keys %$updates ) {
        # kill the old settings if any are there
        $txt =~ s/\$TWiki::cfg\{$config\}\s*=.*?;//s;
    }
    $txt =~ s/^1;$//gm;

    open(F, ">$path_to_localsite_cfg") ||
      die "Failed to open $path_to_localsite_cfg for write";
    print F $txt if $txt;
    foreach my $config ( keys %$updates ) {
        print F '$TWiki::cfg{',$config,'} = ',$updates->{$config},";\n";
    }
    print F "1;\n";
    close(F);

    if( defined( $TWiki::cfg{ConfigurationLogName} ) &&
        open(F, '>>'.$TWiki::cfg{ConfigurationLogName} )) {
        my $date = gmtime();
        my $user = $query->remote_user() || 'guest';
        foreach my $config ( keys %$updates ) {
            print F '| ',$date,' | ',$user,' | ',$config,' | ',
              $updates->{$config}," |\n";
        }
        close(F);
    }
}

sub _perlifyType {
    my ($val,$type) = @_;

    if ($type eq 'REGEX') {
        return "qr($val)";
    } elsif ($type eq 'BOOLEAN') {
        return ($val ? 1 : 0);
    } elsif ($type eq 'NUMBER') {
        return 0+$val;
    } elsif ($type eq 'OCTAL') {
        $val = '0'.$val unless $val =~ /^0/;
        return $val;
    } else {
        $val =~ s/'/\\'/g;
        return "'$val'";
    }
}

sub _setting {
    my( $key, $data ) = @_;
    return CGI::Tr(CGI::td({class=>'firstCol'}, $key).
                   CGI::td({class=>'secondCol'}, $data));
}

my $nextid;

sub _foldableBlock {
    my( $head, $body ) = @_;

    $body = CGI::a( {name => _makeAnchor( $head )}, '').
      CGI::start_table().$body.CGI::end_table();
    my $mess = '&nbsp;';
    $mess .= CGI::span({class=>'error'}, $errors.' error(s)') if $errors;
    $mess .= CGI::span({class=>'warn'}, $warnings.' warning(s)') if $warnings;
    $errors = $warnings = 0;

    my $id = $nextid++;
    return CGI::button( -name => 'but'.$id,
                        -onClick => 'foldBlock("BLOCK'.$id.'")',
                        -value => $head ).
                          $mess.'<br />'.
           CGI::div( { id => 'BLOCK'.$id, class=> 'foldableBlock' },
                     $body ).
                       "\n";
    }

sub _subHead {
    my $text = shift;
    return CGI::Tr(CGI::Td({colspan=>2}, CGI::h3($text))).
      "\n";
}

sub _docBlock {
    my $desc = shift;

    return CGI::Tr( CGI::td( { colspan => 2, class=>'docdata info' }, $desc )).
      "\n";
}

sub handlePlugins {
    my @modules;
    foreach my $libDir ( @INC ) {
        if( opendir( DIR, "$libDir/TWiki/Plugins" ) ) {
            foreach my $file (grep { /^[A-Za-z0-9_]+Plugin\.pm$/ } readdir DIR ) {
                my $module = $file;
                $module =~ s/\.pm$//;
                my $discovered = $libDir.'/'.$file;
                $TWiki::cfg{Plugins}{$module}{Enabled} ||= 0;
                push( @modules, $module );
                closedir( DIR );
            }
        }
    }
    my $block = '';
    foreach my $m ( sort @modules ) {
        $block .= _checkAndBuildValueGrabber
          ( 'BOOLEAN', '', '',
            '{Plugins}{'.$m.'}{Enabled}');
    }
    return $block;
}

sub handleUpdate {
    unless( $update_enabled ) {
        exit;
    }

    my $pass = $query->param( 'cfgAccess' );
    my $param;

    unless( defined( $pass )) {
        print CGI::start_form({ action=>'configure',method=>"post" });
        # Pass all URL params through
        foreach $param ( $query->param ) {
            print CGI::hidden( $param, $query->param( $param )),"\n";
        }
        # and add a few more
        print "You need to enter the configuration password. If this is the first time you have configured TWiki, this will be null, and you should set a new password.",
          CGI::start_table(),
          CGI::Tr(
            CGI::td( "Enter Password:" ),
            CGI::td(CGI::password_field( 'cfgAccess', '', 20, 80 ))),
          CGI::Tr(
           CGI::td( {colspan => 2 },
                     "If you also want to change the password, enter new details below")),
          CGI::Tr(
            CGI::td("New password:"),
            CGI::td(CGI::password_field( 'newCfgP', '', 20, 80 ))),
          CGI::Tr(
            CGI::td("Confirm new password:"),
            CGI::td(CGI::password_field( 'confCfgP', '', 20, 80 ))),
          CGI::end_table(),
          CGI::submit(-value=>'Commit'),
          CGI::end_form(),
          CGI::end_html();
        exit;
    }

    unless( crypt( $pass, $TWiki::cfg{Password}) eq
            $TWiki::cfg{Password} ) {
        print CGI::span( {class => 'error' }, "Incorrect password" ),
          CGI::end_html();
        exit;
    }

    my $changed = 0;
    my %updates;

    if( $query->param( 'newCfgP' )) {
        if( $query->param( 'newCfgP' ) eq
                $query->param( 'confCfgP' )) {
            my @saltchars = ( 'a'..'z', 'A'..'Z', '0'..'9', '.', '/' );
            my $salt = $saltchars[int(rand($#saltchars+1))] .
              $saltchars[int(rand($#saltchars+1)) ];
            $updates{Password} =
              _perlifyType(
                           crypt( $query->param( 'newCfgP' ), $salt ),
                           'STRING' );
            $changed++;
            print "Password changed";
        } else {
            print "New password and confirmation do not match";
            exit;
        }
    }

    print CGI::h1('Updating configuration');
    foreach $param ( $query->param ) {
        next unless $param =~ /^^TYPEOF:(.*)/;
        my $type = $query->param( $param );
        $param =~ s/^TYPEOF://;
        my $basevar = $param;
        $basevar =~ s/_/}{/g;
        my $var = '$TWiki::cfg{'.$basevar.'}';
        my $val = $query->param( $param );
        my $def;
        eval "\$def = defined( $var );";
        if( $type ) {
            eval "\$def = $var;" if $def;
            next if( $type eq 'OCTAL' && sprintf('0%o', $def) =~ /^0*$val$/ );
            next if( $type eq 'NUMBER' && $val + 1 == $def + 1 );
            next if( $type eq 'BOOLEAN' && ($val && $def || !$val && !$def));
            next if( $val eq $def );
            print CGI::h2($var),CGI::b('old '),CGI::code($def),
              CGI::br().CGI::b('new  '),CGI::code($val);
            $updates{$basevar} = _perlifyType($val, $type);
            $changed++;
        }
    }
    print CGI::p();
    setConfig($path_to_localsite_cfg, \%updates);
    print $changed.' configuration items changed. ';
    print CGI::a({ href=>$url.'?t='.time() }, 'Click here to return to configuration');
    exit 1;
}

sub performSanityChecks {

    if ($brokenTWikiCfgError) {
        print CGI::h2('WARNING:'),
          'TWiki.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) should help locate the problem.<p />';
        print $brokenTWikiCfgError;

        # EARLY EXIT
        print CGI::end_html();
        exit;
    }

    if ($brokenLocalSiteError) {
        print CGI::h2('WARNING:'),
          WARN('LocalSite.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) was generated.',
               CGI::pre($brokenLocalSiteError),
               'The @INC path is ',CGI::pre(join(":", @INC)),
               'This may be because this is the first time you have run configure. In this case you can simply ignore this warning until you have filled in your <a href="#GeneralPathSettings">General path settings</a>. Otherwise, check that the file exists, and the webserver user is allowed to read it.<p />');
    }

    # Check whether basic CGI modules exist (some broken installations of
    # Perl don't have this, even though they are standard modules), and warn user
    my $modMissing = 0;
    foreach my $mod (keys %basicMods) {
        eval "use $mod";
        if ($@) {
            unless ($modMissing) {
                print 'Content-Type: text/plain'."\n\n";
                print 'Perl Module(s) missing';
            }
            $modMissing = 1;
            print 'Warning: Essential module ',$mod;
            print 'not installed - please check your Perl installation, ',
              'including the setting of @INC, and re-install Perl if necessary.';
        }
    }

    # If any critical modules missing, display @INC and give up 
    if ($modMissing) {
        print '@INC setting:', join(' ', @INC);
        exit;
    }
}

sub presentReadOnlyInfo {
    # use strict;		# Recommended for mod_perl, enable for Perl 5.6.1 only
    # Doesn't work well here, due to 'do "TWiki.cfg"'
    # use diagnostics;	# Debug only

    # Load CGI modules (run-time, after checking they are accessible)
    require CGI;
    import CGI qw( -any );
    require CGI::Carp;
    import CGI::Carp qw( fatalsToBrowser );

    my $block = '';
    for my $key ( sort keys %ENV ) {
        $block .= _setting($key, $ENV{$key});
    }
    print _foldableBlock('Environment variables (read only)', $block);

    $block = '';

    # Make %ENV safer for CGI (should reflect TWiki.pm)
    my $originalPath = $ENV{'PATH'} || '';
    if( $TWiki::cfg{SafeEnvPath} ) {
        $ENV{'PATH'} = $TWiki::cfg{SafeEnvPath};
    }
    delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

    # Get Perl version - output looks neater with new variable
    if (defined $^V) {
        $perlver = $^V;             # New in Perl 5.6.1, one byte per part
        $perlver = ord(substr($perlver,0)) . "." . ord(substr($perlver,1))
          . "." . ord(substr($perlver,2));
    } else {
        $perlver = $perlvernum
    }
    $perlverMsg = $perlver;		# Default version message

    # Load Config module - used here and elsewhere
    require Config;

    # Set $TWiki::cfg{DetailedOS} if not using later versions of TWiki.cfg for BeijingRelease
    # - this code enables the latest testenv to be used with Dec 2001 and 
    # earlier releases.
    if ( !defined $TWiki::cfg{DetailedOS} ) {
        $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
    }

    # Detect Perl flavour on Windows, and Cygwin Perl/RCS package versions

    if ($TWiki::cfg{DetailedOS} eq 'cygwin') {
        $perltype = 'Cygwin';				# Cygwin Perl only
        my ($pkg, $pkgName);

        # Get Cygwin perl's package version number
        $pkgName = 'perl';
        $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
        if ($?) { 
            $pkg = " [Can't identify package - cygcheck or grep not installed]";
            $perlverMsg = $perlver . $pkg
        } else {
            $pkg = (split ' ', $pkg)[1];	# Package version
            $perlverMsg = $pkg;
        }

        # Get Cygwin RCS's package version number
        $pkgName = 'rcs';
        $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
        if ($?) { 
            $pkg = " [Can't identify package - cygcheck or grep not installed]";
            $cygwinRcsVerNum = $pkg;	
        } else {
            $pkg = (split ' ', $pkg)[1];	# Package version
            $cygwinRcsVerNum = $pkg;	
        }
    } elsif ($TWiki::cfg{DetailedOS} =~ /win/i && $TWiki::cfg{DetailedOS} !~ /darwin/i ) {
        # Windows Perl - try ActivePerl-only function: returns number if
        # successful, otherwise treated as a literal (bareword).
        my $isActivePerl= eval 'Win32::BuildNumber !~ /Win32/';
        if( $isActivePerl ) {
            $perltype = 'ActiveState';
            $perlverMsg = $perlver . ", build " . Win32::BuildNumber();
        } else {
            # Could be SiePerl or some other Win32 port of Perl
            $perltype = 'SiePerl or other Windows Perl';
        }
    } else {
        $perltype = 'generic';
    }

    # Detect executable name suffix, e.g. .exe on Windows or '' on Unix
    # Avoid testing for .exe suffixes on Cygwin, since the built-in
    # grep and ls don't end in '.exe', even though Perl's '_exe' setting
    # indicates they should.
    my $exeSuffix='';
    if ( $Config::Config{'_exe'} and ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype ne 'Cygwin') ) { 
        if ( ! $ENV{'INTERIX_ROOT'} ) { #this is set is we are using UnixServicesForWindows (or INTERIX funnily enough) and they don't use .exe either
            $exeSuffix = $Config::Config{'_exe'};
        }
    }

    # Detect whether mod_perl was loaded into Apache
    my $modPerlLoaded = ( exists $ENV{'SERVER_SOFTWARE'} && 
                          ( $ENV{'SERVER_SOFTWARE'} =~ /mod_perl/ ));
    # Detect whether we are actually running under mod_perl
    # - test for MOD_PERL alone, which is enough.
    my $usingModPerl = ( exists $ENV{'MOD_PERL'} );
    my $modPerlVersion;

    # Get the version of mod_perl if it's being used
    if ( $usingModPerl ) {
        $modPerlVersion = eval 'use mod_perl; return $mod_perl::VERSION';
    }

    my $n = ucfirst(lc($TWiki::cfg{OS}));
    $n .= " ($TWiki::cfg{DetailedOS})" if ( $TWiki::cfg{DetailedOS} ne '' );
    # OS
    $block .= _setting("Operating system", $n);

    # Perl version and type
    $perlverMsg .= " ($perltype)" if $perltype ne 'generic';
    $block .= _setting("Perl version", $perlverMsg);

    if ( $perlvernum < $perlverRequired ) {
        $block .= _setting('',
                           WARN(<<HERE
This version of Perl is too old for use with TWiki -
upgrade to at least Perl $perlverRequiredString
and preferably to Perl $perlverRecommended.
HERE
                               ));
    }

    # Perl @INC (lib path)
    $block .= _setting('@INC library path', join('<br />', @INC ),
                       NOTE(<<HERE
This is the Perl library path, used to load TWiki modules,
third-party modules used by some plugins, and Perl built-in modules.
HERE
                           ));

    $block .= _setting('CGI bin directory', _checkBinDir());

    # Turn off fatalsToBrowser while checking module loads, to avoid load errors in
    # browser in some environments.  
    $CGI::Carp::WRAP = $CGI::Carp::WRAP = 0;	# Avoid warnings...

    # Add to list of required modules if non-Unix, or MacOS X (detected by
    # Perl as 'Darwin') - $TWiki::cfg{DetailedOS} is set in TWiki.cfg.
    $TWiki::cfg{DetailedOS} ||= $TWiki::cfg{DetailedOS};

    # Check that the TWiki.pm module can be found
    eval "require TWiki";
    my $twikiFound = 0;
    my $mess = '';
    if ($@) {
        $mess = ERROR("'TWiki.pm' not be loaded. Error was",
                      CGI::pre($@),
                      'Check path to <code>twiki/lib</code> and check that LocalSite.cfg is present and readable');
    } else {
        $twikiFound = 1;
        my $mod_version = eval '$TWiki::wikiversion || $TWiki::VERSION';
        $mod_version ||= 'unknown';
        $mess = 'OK, TWiki.pm found (Version: <strong>'.$mod_version.'</strong>)';
    }
    $block .= _setting('TWiki module in @INC path', $mess);

    if ( defined $TWiki::cfg{DetailedOS} and ($TWiki::cfg{DetailedOS} =~ /darwin/i or $TWiki::cfg{OS} ne 'UNIX') ) {
        map { $requiredMods{$_} = $requiredModsNonUnix{$_} }
          keys %requiredModsNonUnix;
    } else {
        # these are optional on Unix
        map { $optionalMods{$_} = $requiredModsNonUnix{$_} }
          keys %requiredModsNonUnix;
    }

    # Check that each of the required Perl modules can be loaded, and
    # print its version number.
    $block .= _subHead("Required Perl modules");
    foreach my $mod (keys %requiredMods) {
        eval "use $mod";
        if ($@) {
            $block .= _setting($mod, ERROR("not installed. Required for ",
                                  $requiredMods{$mod}));
        } else {
            my $mod_version;
            no strict 'refs';
            eval '$mod_version = ${'.$mod.'::VERSION}';
            use strict 'refs';
            $n = $mod_version || 'unknown';
            # Check for potential CGI.pm module upgrade 
            if( $mod eq 'CGI' and $mod_version < $cgiModVerRecommended ) {
                if ( $perltype eq 'Cygwin' and $perlver eq '5.8.0' ) {
                    # Recommend CGI.pm upgrade if using Cygwin Perl 5.8.0 
                    $n .= WARN( "CGI.pm version $cgiModVerRecommended or higher",
                                "is recommended to avoid problems with attachment",
                                "uploads on Cygwin Perl $perlver.");
                } elsif ( $usingModPerl and $modPerlVersion >= 1.99 ) {
                    # Recommend CGI.pm upgrade if using mod_perl 2.0, which
                    # is reported as version 1.99 and implies Apache 2.0
                    $n .= WARN("CGI.pm version $cgiModVerRecommended or higher is",
                               "recommended to avoid problems with mod_perl version",
                               "$modPerlVersion on Apache 2.0 or higher.");
                }
            }
            $block .= _setting($mod, $n);
        }
    }

    # Check that each of the optional Perl modules can be loaded, and
    # print its version number.
    $block .= _subHead("Optional Perl modules");
    foreach my $mod (keys %optionalMods) {
        eval "use $mod";
        if ($@) {
            $n = WARN('not installed. May be required for ',
                      $optionalMods{$mod});
        } else {
            my $mod_version;
            no strict 'refs';
            eval '$mod_version = ${'.$mod.'::VERSION}';
            use strict 'refs';
            $n = $mod_version || 'unknown';
        }
        $block .= _setting($mod, $n);
    }

    # All module checks done, OK to enable fatalsToBrowser
    import CGI::Carp qw( fatalsToBrowser );

    # PATH_INFO
    $block .= _setting(CGI::a({name=>'PATH_INFO'},'PATH_INFO'), $query->path_info(),
              NOTE(<<HERE
For a URL such as <strong>$url/foo/bar</strong>,
the correct PATH_INFO is <strong>/foo/bar</strong>, without any prefixed path
components. <a href="$url/foo/bar#PATH_INFO">
<strong>Test this now</strong></a>
- particularly if you are using mod_perl, Apache or IIS, or are using
a web hosting provider.
The page resulting from the test link should have a PATH_INFO of
<strong>/foo/bar</strong>
HERE
                  ));

    # mod_perl 
    my $usingModPerlText = $usingModPerl ? "Used" : "Not used";
    my $modPerlLoadedText = ( $modPerlLoaded ? "loaded" : "not loaded" );

    $n = "$usingModPerlText for this script (mod_perl $modPerlLoadedText into Apache)\n";
    if ( $modPerlVersion ) {
        $n .= "- mod_perl version $modPerlVersion\n";
    }
    $block .= _setting('mod_perl', $n);

    # Check for a broken version of mod_perl 2.0
    if ( $usingModPerl and $modPerlVersion >= 1.99 
         and $modPerlVersion eq '1.99_11' ) {
        # Recommend mod_perl upgrade if using a mod_perl 2.0 version
        # with PATH_INFO bug (see Support.RegistryCookerBadFileDescriptor)
        $block .= _setting('', WARN(<<HERE
mod_perl version $modPerlVersionRecommended or higher,
is strongly recommended to avoid 'internal system error'
bugs with PATH_INFO when using mod_perl $modPerlVersion
and Apache 2.0 or higher.
HERE
                          ));
    }

    # Get web server's user and group info
    my $usr = "";
    my $grp = "";
    if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
        $usr = lc( getpwuid($>) );		# Unix/Cygwin Perl - effective UID
        $grp = join(',', map { lc(getgrgid( $_ )) } split( " ", $( ) );
    } else {				# ActiveState or other Win32 Perl
        $usr = lc( getlogin );
        # Try to use Cygwin's 'id' command - may be on the path, since Cygwin
        # is probably installed to supply ls, egrep, etc - if it isn't, give up.
        # Run command without stderr output, to avoid CGI giving error.
        # Get names of primary and other groups.
        $grp = lc(qx(sh -c '( id -un ; id -gn) 2>/dev/null' 2>nul ));
        if ($?) { 
            $grp = "[Can't identify groups - no Cygwin 'id' or 'sh' command on path]";
        }
    }

    $block .= _setting('CGI user', 'userid = <strong>'.$usr.'</strong> groups = <strong>'.
              $grp.'</strong>'.
              NOTE('Your CGI scripts are executing as this user.'));

    # Check PATH
    # Generate a separate table about specific environment variables
    $block .= _subHead("Shell and Path");

    $block .= _setting("Original PATH", $originalPath,
              NOTE(<<HERE
This is the PATH value passed in from the web server to this
script - it is reset by TWiki scripts to the PATH below, and
is provided here for comparison purposes only.
HERE
                  ));

    my $currentPath = $ENV{'PATH'} || ''; 	# As re-set earlier in this routine
    $block .= _setting("Current PATH", $currentPath,
              NOTE(<<HERE
This is the actual PATH setting that will be used by Perl to run
programs. It is normally identical to {SafeEnvPath}, unless
that variable is empty, in which case this will be the webserver users
standard path..
HERE
                  ));

    
    # Check that GNU egrep is found in PATH
    my $egrepBad = checkGnuVersion( $TWiki::cfg{RCS}{EgrepCmd}, "egrep", "used for regular expression searches" );

    # Check that GNU fgrep is found in PATH
    my $fgrepBad = checkGnuVersion( $TWiki::cfg{RCS}{FgrepCmd}, "fgrep", "used for non-regular expression searches" );

    if( $egrepBad || $fgrepBad ) {
        $block .= $egrepBad . $fgrepBad;
        $block .= _setting('',  NOTE( qq{<a href="http://www.gnu.org/software/grep/grep.html" >grep</a> can be downloaded from <a href="http://www.gnu.org/">GNU</a>'s <a href="ftp://ftp.gnu.org/pub/gnu/grep/" >FTP</a> site} ));
    }

    # Check that GNU diff is found in PATH
    $block .= checkGnuVersion( "diff", "diff", "used by RCS to compare files" );

    # Check that GNU patch is found in PATH 
    $block .= checkGnuVersion( "patch", "patch", "used by the UpgradeTwiki script to upgrade an existing TWiki installation" );

    # PERL5SHELL check for non-Cygwin Perl on Windows only
    if( $TWiki::cfg{OS} eq 'WINDOWS' && $perltype ne 'Cygwin' ) {

        # ActiveState or SiePerl/other
        # FIXME: Advice in this section should be reviewed and tested by people
        # using ActivePerl
        my $perl5shell = $ENV{'PERL5SHELL'} || '';
        $n = $perl5shell.
          NOTE(<<HERE
This environment variable is used by ActiveState and other Win32 Perls to run
commands from TWiki scripts - it determines which shell program is used to run
commands that use 'pipes'.  Examples of shell programs are cmd.exe,
command.com (aka 'DOS Prompt'), and Cygwin's 'bash'
(<strong>recommended</strong> if Cygwin is installed).
<p>
To use 'bash' with ActiveState or other Win32 Perl you should set the
PERL5SHELL environment variable to something like
<tt><strong>c:/YOURCYGWINDIR/bin/bash.exe -c</strong></tt>
This should be set in the System Environment, and ideally set directly in the
web server (e.g. using the Apache <tt>SetEnv</tt> directive).
HERE
              );
        if ($perltype eq 'ActiveState' and 
            Win32::BuildNumber() < $ActivePerlRecommendedBuild ) {
            $n .= WARN("ActiveState Perl must be upgraded to build <strong>",
                       $ActivePerlRecommendedBuild,
                       "</strong> if you are going to use PERL5SHELL, which was broken",
                       "in earlier builds.");
        }
        $block .= _setting("PERL5SHELL", $n);
    };
    print _foldableBlock('CGI Setup (read only)', $block);

};

sub presentEditableInfo {
    # "Parse" TWiki.cfg and LocalSite.cfg
    my $block = '';
    my $head = '';
    for my $file ( 'TWiki.cfg', 'LocalSite.cfg' ) {
        my $cfgfile = _findFileOnPath($file);
        open(F, $cfgfile) || next;
        undef $/;
        my $text = <F>;
        close(F);
        $text =~ s/^# //gm;

        my $type;
        my $descr;
        my $opts;
        foreach (split(/\r?\n/, $text)) {
            if( m/^\*\*([A-Z]+)(\s*.*?)\*\*/ ) {
                if( $type eq '_HELP' ) {
                    $block .= _docBlock( $descr );
                }
                $type = $1;
                $opts = $2 || '';
                $opts .= ' '; # to simplify parsing
                $descr = '';
            } elsif ($type && /\$(TWiki::)?cfg(.*?)\s*=/) {
                if( $type eq '_HELP' ) {
                    $block .= _docBlock( $descr );
                } else {
                    $block .= _checkAndBuildValueGrabber($type, $opts, $descr, $2);
                }
                $type = '';
                $descr = '';
            } elsif( m/^##+(.*?)#+$/ ) {
                if( $block ) {
                    print _foldableBlock( $head, $block );
                }
                $head = $1;
                $block = '';
                $type = '_HELP';
            } elsif( m/^\*PLUGINS\*/ ) {
                if( $type eq '_HELP' ) {
                    $block .= _docBlock( $descr );
                    $descr = '';
                }
                $block .= handlePlugins();
            } elsif( $type ) {
                $descr .= "$_ ";
            }
        }
    }
    if( $head || $block ) {
        print _foldableBlock( $head, $block );
    }
}

######################################################################
################# MAIN PROGRAM #######################################
######################################################################

$| = 1;                  # no buffering - FIXME: mod_perl issue?


eval "use CGI::Carp qw( fatalsToBrowser )";

# Set library paths in @INC, read TWiki.cfg and set locale, at compile time
# Try to use setlib.cfg, use default path if missing
if ( -r './setlib.cfg' ) {
    require './setlib.cfg'; 
    $setlibAvail = 1;
} else {
    unshift @INC, '../lib';
    $setlibAvail = 0;
}

if( $OS ) {
    $TWiki::cfg{DetailedOS} = $detailedOS;
    $TWiki::cfg{OS} = $OS;
} else {
    # SMELL: duplicates code in TWiki.pm
    unless( ( $TWiki::cfg{DetailedOS} = $^O ) ) {
        require Config;
        $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
    }
    $TWiki::cfg{OS} = 'UNIX';
    if ($TWiki::cfg{DetailedOS} =~ /darwin/i) { # MacOS X
        $TWiki::cfg{OS} = 'UNIX';
    } elsif ($TWiki::cfg{DetailedOS} =~ /Win/i) {
        $TWiki::cfg{OS} = 'WINDOWS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /vms/i) {
        $TWiki::cfg{OS} = 'VMS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /bsdos/i) {
        $TWiki::cfg{OS} = 'UNIX';
    } elsif ($TWiki::cfg{DetailedOS} =~ /dos/i) {
        $TWiki::cfg{OS} = 'DOS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /^MacOS$/i) { # MacOS 9 or earlier
        $TWiki::cfg{OS} = 'MACINTOSH';
    } elsif ($TWiki::cfg{DetailedOS} =~ /os2/i) {
        $TWiki::cfg{OS} = 'OS2';
    }
}

# if this fails, ignore the problem, but we have to do it
unless( eval 'do "LocalSite.cfg"' ) {
    # Capture the Perl error(s)
    $brokenLocalSiteError = 'require failed: '.
      ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
}

# Read the configuration file now in order to set locale;
# includes checking for broken syntax etc.  Need 'require'
# to get the $!/$@ to work.
$brokenTWikiCfg = 0;
unless( eval 'require "TWiki.cfg" ' ) {
    # Capture the Perl error(s)
    $brokenTWikiCfgError = 'require failed: '.
      ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
}

# and again
eval 'do "LocalSite.cfg"';

# Do a dynamic 'use locale' for this script
if( $TWiki::cfg{UseLocale} ) {
    require locale;
    import locale ();
}

print CGI::header('text/html'),
  CGI::start_html( -title => 'TWiki Configuration' ),
  CGI::style( { type=>'text/css', media=>'all' }, <<'HERE'
html body {
  line-height:1.55em;
  font-family:Avenir, "Lucida Grande", "Bitstream Vera Sans", lucida, arial, verdana, sans-serif;
  background-color: white;
  margin:0;
  padding:0;
}
h1 {
  font-size:210%;
  background-color:#DFDFDF;
  padding:0.2em 0.7em;
  color:#C90000;
  margin:1em -0.7em 0.15em -0.7em;
}
h2 {
  background-color:#F0F0F0;
  padding:2ex 0.7em 0.2em 0.7em;
}
h3 {
  padding:0.2em 0.7em;
}
.info {
  color: green;
}
.warn {
  color:#FF8800;;
}
.error {
  color:red;
  font-weight: bold;
}
.mandatory {
  color: blue;
  font-weight: bold;
}
.docdata {
  vertical-align: top;
  padding-top: 1ex;
}
.keydata {
  font-weight: bold;
  background-color:#FOFOFO;
}
.foldableBlock{
  display: none;
}
.firstCol {
   font-weight: bold;
}
.secondCol {
}
HERE
            ),
  CGI::script( { language => 'JavaScript' }, <<'HERE'
function foldBlock(id) {
    var element = document.getElementById(id);
    if( element.style.display == 'block' ) {
        element.style.display = 'none';
    } else {
        element.style.display = 'block';
    }
}
HERE
             );

print CGI::h1('TWiki Configuration');

# Check if LocalSite.cfg is writable
$path_to_localsite_cfg = _findFileOnPath('LocalSite.cfg');
unless( $path_to_localsite_cfg ) {
    $path_to_localsite_cfg = _findFileOnPath('TWiki.cfg') || '';
    $path_to_localsite_cfg =~ s/TWiki\.cfg/LocalSite.cfg/;
}
my $errs;
if( !$path_to_localsite_cfg ||
    ( $errs = _checkCanCreateFile( $path_to_localsite_cfg ))) {
    $errs ||= 'Cannot locate LocalSite.cfg';
    print CGI::p(WARN('Save is disabled; '.$errs));
} else {
    $update_enabled = 1;
}

performSanityChecks();

if( $action eq 'update' ) {
    handleUpdate();
} else {
    print  <<HERE;
This page is used to set up the configuration options for TWiki. Settings
marked <span class='mandatory'>like this</span> are required (they must
have a value). Fill in the settings, and then select 'Save'.
TWiki will be reconfigured and you can return to this page. Any
remaining <span class='error'>errors</span> in your configuration will then be highlighted. <span class='warn'>Warnings</span> are non-fatal, but are often a good indicator that something that is wrong.
<p />
If you are installing TWiki for the first time, and you just want to get up
and running, the only section you need to worry about below is
<a href="#GeneralPathSettings">General path settings</a>. You can always come
back and configure other settings later.
<p />
If you are on a public site, you will need to consider carefully
how you are going to manage authentication and access control.
<p />
There are a number of documentation topics describing how to
configure TWiki for different platforms, and a lot of support
available on IRC (irc.freenode.net, channel #twiki) and at TWiki.org.
<p />
If your TWiki site is working, the front page should be
<a href="$TWiki::cfg{ScriptUrlPath}/view$TWiki::cfg{ScriptSuffix}">right here</a>

Click on the buttons below to open each section.
HERE

    if( $update_enabled ) {
        print CGI::start_form({ action=>'configure',method=>"post" });
        # use time to make sure we never allow cacheing
        print CGI::hidden(-name=>'action',-value=>'update');
        print CGI::hidden(-name=>'time',-value=>time());

    }

    presentReadOnlyInfo();
    presentEditableInfo();

    print CGI::end_table().'<br />';
    print CGI::span({class=>'error'},$toterrors.' errors') if $toterrors;
    print CGI::span({class=>'warn'},$totwarnings.' warnings') if $totwarnings;

    if( $update_enabled) {
        print CGI::p(CGI::submit(-value=>'Save')),CGI::end_form();
    }
}

print CGI::end_html();

1;
