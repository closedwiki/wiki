#!/usr/bin/perl -w
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at 
# http://www.gnu.org/copyleft/gpl.html
#
# Configuration script for TWiki. Once you have a basic webserver
# configuration that lets you access this script, the rest of the
# configuration process is done from here. This script replaces
# the old "testenv" script.
#
# The script works by accepting values into a CGI form, and then
# submitting those values back to itself with a parameter (update)
# set to 1. This causes it to write config changes to LocalSite.cfg.
# Note that changes are only written if there is a real change in the
# value.
#
# The values available to configuration are determined by parsing
# TWiki.cfg. Special full-line comments guide the parse:
# Any comment of the form
######## Some text #########
# is taken as a H2 heading, and following comments are dragged in too.
# Comments of the form
# **TYPE opts**
# where TYPE is one of URL, PATH, URLPATH, BOOLEAN, STRING, REGEX, SELECT
# are used to indicate that a following cfg var is configurable through
# the interface. All intermediate comments are taken as documentation for
# the value.
#
package TWiki;

# BASIC checks. Without these, nothing works.

use strict;
my $setlibAvail;
my $brokenTWikiCfg;
my $brokenTWikiCfgError;
my $brokenLocalSiteError;
my %cfg; # TWiki config
my $OS;
my $detailedOS;
my $cygwinRcsVerNum;
my $perlverRequired = 5.00503;		# Oldest supported version of Perl
my $perlverRequiredString = '5.005_03';
my $perlverRecommended = '5.6.1';
my $perlVerPreferred = 5.006;	# 5.6 or higher has [:lower:] etc
my $ActivePerlRecommendedBuild = 631;	# Fixes PERL5SHELL bugs

# CGI.pm version, on some platforms - actually need CGI 2.93 for mod_perl
# 2.0 and CGI 2.90 for Cygwin Perl 5.8.0.  See 
# http://perl.apache.org/products/apache-modules.html#Porting_CPAN_modules_to_mod_perl_2_0_Status
my $cgiModVerRecommended = '2.93';	

# Recommended mod_perl version if using mod_perl 2.0 (see Support.RegistryCookerBadFileDescriptor)
my $modPerlVersionRecommended = '1.99_12';	

my $rcsverRequired = 5.7;
use vars qw( $TRUE $FALSE);

#local $SIG{__DIE__} = sub { Carp::confess $_[0] };

BEGIN {
    $TRUE = 1;
    $FALSE = 0;
    # Set default current working directory
    if( $ENV{"SCRIPT_FILENAME"} && $ENV{"SCRIPT_FILENAME"} =~ /^(.+)\/[^\/]+$/ ) {
        chdir $1;
    }
}

# Required for testenv to work
my %basicMods =
  (
   'CGI'       => "basic TWiki",
   'CGI::Carp' => "basic TWiki"
  );

$| = 1;                  # no buffering - FIXME: mod_perl issue?

# Check whether basic CGI modules exist (some broken installations of
# Perl don't have this, even though they are standard modules), and warn user
my $modMissing = 0;
foreach my $mod (keys %basicMods) {
    eval "use $mod";
    if ($@) {
        unless ($modMissing) {
            print 'Content-Type: text/plain'."\n\n";
            print 'Perl Module(s) missing';
        }
        $modMissing = 1;
        print 'Warning: Essential module ',$mod;
        print 'not installed - please check your Perl installation, ',
          'including the setting of @INC, and re-install Perl if necessary.';
    }
}

# If any critical modules missing, display @INC and give up 
if ($modMissing) {
    print '@INC setting:', join(' ', @INC);
    exit;
}

eval "use CGI::Carp qw( fatalsToBrowser )";

# Set library paths in @INC, read TWiki.cfg and set locale, at compile time
# Try to use setlib.cfg, use default path if missing
if ( -r './setlib.cfg' ) {
    require './setlib.cfg'; 
    $setlibAvail = 1;
} else {
    unshift @INC, '../lib';
    $setlibAvail = 0;
}

if( $OS ) {
    $TWiki::cfg{DetailedOS} = $detailedOS;
    $TWiki::cfg{OS} = $OS;
} else {
    # SMELL: duplicates code in TWiki.pm
    unless( ( $TWiki::cfg{DetailedOS} = $^O ) ) {
        require Config;
        $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
    }
    $TWiki::cfg{OS} = 'UNIX';
    if ($TWiki::cfg{DetailedOS} =~ /darwin/i) { # MacOS X
        $TWiki::cfg{OS} = 'UNIX';
    } elsif ($TWiki::cfg{DetailedOS} =~ /Win/i) {
        $TWiki::cfg{OS} = 'WINDOWS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /vms/i) {
        $TWiki::cfg{OS} = 'VMS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /bsdos/i) {
        $TWiki::cfg{OS} = 'UNIX';
    } elsif ($TWiki::cfg{DetailedOS} =~ /dos/i) {
        $TWiki::cfg{OS} = 'DOS';
    } elsif ($TWiki::cfg{DetailedOS} =~ /^MacOS$/i) { # MacOS 9 or earlier
        $TWiki::cfg{OS} = 'MACINTOSH';
    } elsif ($TWiki::cfg{DetailedOS} =~ /os2/i) {
        $TWiki::cfg{OS} = 'OS2';
    }
}

# if this fails, ignore the problem, but we have to do it
unless( eval 'do "LocalSite.cfg"' ) {
    # Capture the Perl error(s)
    $brokenLocalSiteError = 'require failed: '.
      ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
}

# Read the configuration file now in order to set locale;
# includes checking for broken syntax etc.  Need 'require'
# to get the $!/$@ to work.
$brokenTWikiCfg = 0;
unless( eval 'require "TWiki.cfg" ' ) {
    # Capture the Perl error(s)
    $brokenTWikiCfgError = 'require failed: '.
      ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
}

# and again
eval 'do "LocalSite.cfg"';

# Do a dynamic 'use locale' for this script
if( $TWiki::cfg{UseLocale} ) {
    require locale;
    import locale ();
}

my $errors = 0;
my $warnings = 0;

my $query = new CGI;
my $url = $query->url();
my $update = $query->param('update');

print CGI::header('text/html'),
  CGI::start_html('TWiki Configuration'),
  CGI::style( { type=>'text/css', media=>'all' }, <<'HERE'
		html body {
			line-height:1.55em;
			font-family:Avenir, "Lucida Grande", "Bitstream Vera Sans", lucida, arial, verdana, sans-serif;
			background-color: white;
			margin:0;
			padding:0;
		}
		h1 {
		    font-size:210%;
		    background-color:#DFDFDF;
		    padding:0.2em 0.7em;
		    color:#C90000;
		    margin:1em -0.7em 0.15em -0.7em;
		}
		h2 {
		    background-color:#F0F0F0;
		    padding:2ex 0.7em 0.2em 0.7em;
		}
		h3 {
		    padding:0.2em 0.7em;
		}
        .info {
            color: green;
        }
        .warn {
			color:orange;
        }
        .error {
			color:red;
            font-weight: bold;
        }
        .mandatory {
			color: blue;
            font-weight: bold;
        }
        .docdata {
            vertical-align: top;
            padding-top: 1ex;
        }
        .keydata {
            vertical-align: top;
            font-weight: bold;
			background-color:#FOFOFO;
        }
HERE
            );

if( $update ) {
    print CGI::h1('Updating configuration');
    my $changed = 0;
    my %updates;
    foreach my $param ( $query->param ) {
        my $basevar = $param;
        $basevar =~ s/_/}{/g;
        my $var = '$TWiki::cfg{'.$basevar.'}';
        my $val = $query->param( $param );
        my $type = $query->param('TYPEOF:'.$param);
        my $def;
        eval "\$def = defined( $var );";
        if( $def ) {
            eval "\$def = $var;";
            if( $val eq $def) {
                print CGI::br($var.'='.$val.' is unchanged ('.$def.')');
                next;
            }
            print CGI::h2($var),
              CGI::b('old ').CGI::code($def).
                  CGI::br(CGI::b('new  ').CGI::code($val));
            $updates{$basevar} = perlifyType($val,$type);
            $changed++;
        }
    }
    print CGI::p();
    setConfig(\%updates);
    print $changed.' configuration items changed. ';
    print CGI::a({ href=>$url.'?t='.time() }, 'Click here to return to configuration');
    exit 1;
}

# use strict;		# Recommended for mod_perl, enable for Perl 5.6.1 only
# Doesn't work well here, due to 'do "TWiki.cfg"'
# use diagnostics;	# Debug only

if ($brokenTWikiCfgError) {
    print CGI::h3("Configuration error");
    print CGI::h2('WARNING:');
    print 'TWiki.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) should help locate the problem.<p />';
    print $brokenTWikiCfgError;

    # EARLY EXIT
    print CGI::end_html();
    exit;
}

if ($brokenLocalSiteError) {
    print CGI::h3('Configuration error'),
      CGI::h2('WARNING:'),
          'LocalSite.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) should help locate the problem.<p />',
            $brokenLocalSiteError, CGI::end_html();
    exit;
}

my %requiredMods =
  (
   'File::Copy' => 'basic TWiki',
   'File::Spec' => 'basic TWiki',
   'FileHandle' => 'basic TWiki',
  );

# Required on non-Unix platforms (mainly Windows)
my %requiredModsNonUnix =
  (
   'Digest::SHA1' => "register script",
   'MIME::Base64' => "register script",
   'Net::SMTP'    => "registration emails and mailnotify",
  );

# Optional modules on all platforms
my %optionalMods =
  (
   'MIME::Base64'     => "HTTP Authentication to proxies (CPAN)",
   'POSIX'            => "I18N (core module) and Security",
   'Digest::MD5'      => "MD5 encoded passwords",
   'Encode'           => "I18N conversions (core module in Perl 5.8)",
   'Unicode::MapUTF8' => "I18N conversions (CPAN)",
   'Unicode::Map'     => "I18N conversions (CPAN)",
   'Unicode::Map8'    => "I18N conversions (CPAN)",
   'Jcode'            => "I18N conversions (CPAN)",
  );

# Load CGI modules (run-time, after checking they are accessible)
require CGI;
import CGI qw( -any );
require CGI::Carp;
import CGI::Carp qw( fatalsToBrowser );

print  <<HERE;
<h1> TWiki Configuration </h1>
This page is used to set up the configuration options for TWiki. Settings
marked <span class='mandatory'>like this</span> are required (they must
have a value). Fill in the settings, and then select 'Update'.
TWiki will be reconfigured and you will be returned to this page. Any
<span class='error'>errors</span> in your configuration will be highlighted. <span class='warn'>Warnings</span> are non-fatal but are often an indicator of something that is wrong.
<p />
If you are installing TWiki for the first time, and you just want to get up
and running, the only section you need to worry about below is
<a href="#GeneralPathSettings">General path settings</a>. You can always come
back and configure other settings later.
<p />
If you are on a public site, you will need to consider carefully
how you are going to manage authentication and access control.
<p />
There are a number of documentation topics describing how to
configure TWiki for different platforms, and a lot of support
available on IRC (irc.freenode.net, channel #twiki) and at TWiki.org.
<p />
If your TWiki site is working, the front page should be
<a href="$TWiki::cfg{ScriptUrlPath}/view$TWiki::cfg{ScriptSuffix}">right here</a>
HERE

print CGI::start_form({ action=>'configure',method=>"post" }),
  CGI::start_table();

# use time to make sure we never allow cacheing
print CGI::hidden(-name=>'update',-value=>time());

print H2('Environment variables (read only)');
for my $key ( sort keys %ENV ) {
    print CGI::Tr( CGI::th($key).CGI::td($ENV{$key}));
}

print H2('CGI Setup (read only)');
# Make %ENV safer for CGI (should reflect TWiki.pm)
my $originalPath = $ENV{'PATH'} || '';
if( $TWiki::cfg{SafeEnvPath} ) {
    $ENV{'PATH'} = $TWiki::cfg{SafeEnvPath};
}
delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

# Get Perl version - output looks neater with new variable
my $perlvernum = $];
my $perlver;
if (defined $^V) {
    $perlver = $^V;             # New in Perl 5.6.1, one byte per part
    $perlver = ord(substr($perlver,0)) . "." . ord(substr($perlver,1))
                                       . "." . ord(substr($perlver,2));
} else {
    $perlver = $perlvernum
}
my $perlverMsg = $perlver;		# Default version message

# Load Config module - used here and elsewhere
require Config;

# Set $TWiki::cfg{DetailedOS} if not using later versions of TWiki.cfg for BeijingRelease
# - this code enables the latest testenv to be used with Dec 2001 and 
# earlier releases.
if ( !defined $TWiki::cfg{DetailedOS} ) {
    $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
}

# Detect Perl flavour on Windows, and Cygwin Perl/RCS package versions
use vars qw($perltype);

if ($TWiki::cfg{DetailedOS} eq 'cygwin') {
    $perltype = 'Cygwin';				# Cygwin Perl only
    my ($pkg, $pkgName);

    # Get Cygwin perl's package version number
    $pkgName = 'perl';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$perlverMsg = $perlver . $pkg
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$perlverMsg = $pkg;
    }
	
    # Get Cygwin RCS's package version number
    $pkgName = 'rcs';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$cygwinRcsVerNum = $pkg;	
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$cygwinRcsVerNum = $pkg;	
    }
} elsif ($TWiki::cfg{DetailedOS} =~ /win/i && $TWiki::cfg{DetailedOS} !~ /darwin/i ) {
    # Windows Perl - try ActivePerl-only function: returns number if
    # successful, otherwise treated as a literal (bareword).
    my $isActivePerl= eval 'Win32::BuildNumber !~ /Win32/';
    if( $isActivePerl ) {
	$perltype = 'ActiveState';
        $perlverMsg = $perlver . ", build " . Win32::BuildNumber();
    } else {
	# Could be SiePerl or some other Win32 port of Perl
	$perltype = 'SiePerl or other Windows Perl';
    }
} else {
    $perltype = 'generic';
}

# Detect executable name suffix, e.g. .exe on Windows or '' on Unix
# Avoid testing for .exe suffixes on Cygwin, since the built-in
# grep and ls don't end in '.exe', even though Perl's '_exe' setting
# indicates they should.
my $exeSuffix='';
if ( $Config::Config{'_exe'} and ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype ne 'Cygwin') ) { 
    if ( ! $ENV{'INTERIX_ROOT'} ) { #this is set is we are using UnixServicesForWindows (or INTERIX funnily enough) and they don't use .exe either
        $exeSuffix = $Config::Config{'_exe'};
    }
}

# Detect whether mod_perl was loaded into Apache
my $modPerlLoaded = ( exists $ENV{'SERVER_SOFTWARE'} && 
			  ( $ENV{'SERVER_SOFTWARE'} =~ /mod_perl/ ));
# Detect whether we are actually running under mod_perl
# - test for MOD_PERL alone, which is enough.
my $usingModPerl = ( exists $ENV{'MOD_PERL'} );
my $modPerlVersion;

# Get the version of mod_perl if it's being used
if ( $usingModPerl ) {
    $modPerlVersion = eval 'use mod_perl; return $mod_perl::VERSION';
}

my $n = ucfirst(lc($TWiki::cfg{OS}));
$n .= " ($TWiki::cfg{DetailedOS})" if ( $TWiki::cfg{DetailedOS} ne '' );
# OS
print ROW("Operating system", $n);

# Perl version and type
$perlverMsg .= " ($perltype)" if $perltype ne 'generic';
print ROW("Perl version", $perlverMsg);

if ( $perlvernum < $perlverRequired ) {
    print ROW('', WARN(<<HERE
This version of Perl is too old for use with TWiki -
upgrade to at least Perl $perlverRequiredString
and preferably to Perl $perlverRecommended.
HERE
                      ));
}

# Perl @INC (lib path)
print ROW('@INC library path', join('<br />', @INC ), NOTE(<<HERE
This is the Perl library path, used to load TWiki modules,
third-party modules used by some plugins, and Perl built-in modules.
HERE
         ));

print ROW('CGI bin directory', _checkBinDir());

# Turn off fatalsToBrowser while checking module loads, to avoid load errors in
# browser in some environments.  
$CGI::Carp::WRAP = $CGI::Carp::WRAP = 0;	# Avoid warnings...

# Add to list of required modules if non-Unix, or MacOS X (detected by
# Perl as 'Darwin') - $TWiki::cfg{DetailedOS} is set in TWiki.cfg.
$TWiki::cfg{DetailedOS} ||= $TWiki::cfg{DetailedOS};

# Check that the TWiki.pm module can be found
my $mod = 'TWiki';
eval "require $mod";
my $twikiFound = 0;
my $mess = '';
if ($@) {
    $mess = WARN("'$mod.pm' not found - check path to <code>twiki/lib</code>",
         "and edit <code>twiki/bin/LocalLib.cfg</code> if necessary");
} else {
    $twikiFound = 1;
    my $mod_version = eval '$TWiki::wikiversion || $TWiki::VERSION';
    $mod_version ||= 'unknown';
    $mess = "OK, $mod.pm found (Version: <strong>$mod_version</strong>)";
}
print ROW('TWiki module in @INC path', $mess);

if ( defined $TWiki::cfg{DetailedOS} and ($TWiki::cfg{DetailedOS} =~ /darwin/i or $TWiki::cfg{OS} ne 'UNIX') ) {
    map { $requiredMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
} else {
    # these are optional on Unix
    map { $optionalMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
}

# Check that each of the required Perl modules can be loaded, and
# print its version number.
print H3("Required Perl modules");
foreach my $mod (keys %requiredMods) {
    eval "use $mod";
    if ($@) {
        print ROW($mod, ERROR("not installed. Required for ",
                              $requiredMods{$mod}));
    } else {
        my $mod_version;
        no strict 'refs';
        eval '$mod_version = ${'.$mod.'::VERSION}';
        use strict 'refs';
        $n = $mod_version || 'unknown';
        # Check for potential CGI.pm module upgrade 
        if( $mod eq 'CGI' and $mod_version < $cgiModVerRecommended ) {
            if ( $perltype eq 'Cygwin' and $perlver eq '5.8.0' ) {
                # Recommend CGI.pm upgrade if using Cygwin Perl 5.8.0 
                $n .= WARN( "CGI.pm version $cgiModVerRecommended or higher",
                            "is recommended to avoid problems with attachment",
                            "uploads on Cygwin Perl $perlver.");
            } elsif ( $usingModPerl and $modPerlVersion >= 1.99 ) {
                # Recommend CGI.pm upgrade if using mod_perl 2.0, which
                # is reported as version 1.99 and implies Apache 2.0
                $n .= WARN("CGI.pm version $cgiModVerRecommended or higher is",
                           "recommended to avoid problems with mod_perl version",
                           "$modPerlVersion on Apache 2.0 or higher.");
            }
        }
        print ROW($mod, $n);
    }
}

# Check that each of the optional Perl modules can be loaded, and
# print its version number.
print H3("Optional Perl modules");
foreach $mod (keys %optionalMods) {
    eval "use $mod";
    if ($@) {
        $n = WARN('not installed. May be required for ',
                  $optionalMods{$mod});
    } else {
        my $mod_version;
        no strict 'refs';
        eval '$mod_version = ${'.$mod.'::VERSION}';
        use strict 'refs';
        $n = $mod_version || 'unknown';
    }
    print ROW($mod, $n);
}

# All module checks done, OK to enable fatalsToBrowser
import CGI::Carp qw( fatalsToBrowser );

# PATH_INFO
print ROW(CGI::a({name=>'PATH_INFO'},'PATH_INFO'), $query->path_info(),
          NOTE(<<HERE
For a URL such as <strong>$url/foo/bar</strong>,
the correct PATH_INFO is <strong>/foo/bar</strong>, without any prefixed path
components. <a href="$url/foo/bar#PATH_INFO">
<strong>Test this now</strong></a>
- particularly if you are using mod_perl, Apache or IIS, or are using
a web hosting provider.
The page resulting from the test link should have a PATH_INFO of
<strong>/foo/bar</strong>
HERE
                        ));

# mod_perl 
my $usingModPerlText = $usingModPerl ? "Used" : "Not used";
my $modPerlLoadedText = ( $modPerlLoaded ? "loaded" : "not loaded" );

$n = "$usingModPerlText for this script (mod_perl $modPerlLoadedText into Apache)\n";
if ( $modPerlVersion ) {
    $n .= "- mod_perl version $modPerlVersion\n";
}
print ROW('mod_perl', $n);

# Check for a broken version of mod_perl 2.0
if ( $usingModPerl and $modPerlVersion >= 1.99 
        and $modPerlVersion eq '1.99_11' ) {
    # Recommend mod_perl upgrade if using a mod_perl 2.0 version
    # with PATH_INFO bug (see Support.RegistryCookerBadFileDescriptor)
    print ROW('', WARN(<<HERE
mod_perl version $modPerlVersionRecommended or higher,
is strongly recommended to avoid 'internal system error'
bugs with PATH_INFO when using mod_perl $modPerlVersion
and Apache 2.0 or higher.
HERE
                      ));
}


# Get web server's user and group info
my $usr = "";
my $grp = "";
if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
    $usr = lc( getpwuid($>) );		# Unix/Cygwin Perl - effective UID
    $grp = join(',', map { lc(getgrgid( $_ )) } split( " ", $( ) );
} else {				# ActiveState or other Win32 Perl
    $usr = lc( getlogin );
    # Try to use Cygwin's 'id' command - may be on the path, since Cygwin
    # is probably installed to supply ls, egrep, etc - if it isn't, give up.
    # Run command without stderr output, to avoid CGI giving error.
    # Get names of primary and other groups.
    $grp = lc(qx(sh -c '( id -un ; id -gn) 2>/dev/null' 2>nul ));
    if ($?) { 
        $grp = "[Can't identify groups - no Cygwin 'id' or 'sh' command on path]";
    }
}

print ROW('CGI user', 'userid = <strong>'.$usr.'</strong> groups = <strong>'.
          $grp.'</strong>'.
          NOTE('Your CGI scripts are executing as this user.'));

H2("Configuration");

$n = "This is used to initialise the PATH variable, and is used to run the".
  " 'diff' program used by RCS, as well as to run shell programs such as ";
if( $TWiki::cfg{OS} eq 'WINDOWS' ) {
    $n .= " cmd.exe or Cygwin's 'bash'.<p>";
    if( $perltype eq 'Cygwin' ) {
        $n .= "Since you are using Cygwin Perl, 'bash' will be used without any special setup.";
    } elsif( $perltype eq 'ActiveState' ) {
        $n .= "To use 'bash' with ActiveState Perl, see the PERL5SHELL section below\n";
        $n .= "- this is recommended if Cygwin is installed.\n";
    }
    $n .= "</p>";
} else {
    $n .= "Bourne shell or 'bash'.";
}

# Generate a separate table about specific environment variables
H2("Path and Shell Environment");

# Check PATH

print ROW("Original PATH", $originalPath,
          NOTE(<<HERE
This is the PATH value passed in from the web server to this
script - it is reset by TWiki scripts to the PATH below, and
is provided here for comparison purposes only.
HERE
              ));

my $currentPath = $ENV{'PATH'} || ''; 	# As re-set earlier in this routine
print ROW("Current PATH", $currentPath,
          NOTE(<<HERE
This is the actual PATH setting that will be used by Perl to run
programs. It is normally identical to {SafeEnvPath}, unless
that variable is empty, in which case this will be the webserver users
standard path..
HERE
              ));


# Check that GNU egrep is found in PATH
my $egrepOk = checkGnuVersion( $TWiki::cfg{RCS}{EgrepCmd}, "egrep", "used for regular expression searches" );

# Check that GNU fgrep is found in PATH
my $fgrepOk = checkGnuVersion( $TWiki::cfg{RCS}{FgrepCmd}, "fgrep", "used for non-regular expression searches" );

unless ( $egrepOk && $fgrepOk ) {
    print ROW('',  NOTE( qq{<a href="http://www.gnu.org/software/grep/grep.html" >grep</a> can be downloaded from <a href="http://www.gnu.org/">GNU</a>'s <a href="ftp://ftp.gnu.org/pub/gnu/grep/" >FTP</a> site} ));
}

# Check that GNU diff is found in PATH
checkGnuVersion( "diff", "diff", "used by RCS to compare files" );

# Check that GNU patch is found in PATH 
checkGnuVersion( "patch", "patch", "used by the UpgradeTwiki script to upgrade an existing TWiki installation" );

# PERL5SHELL check for non-Cygwin Perl on Windows only
if( $TWiki::cfg{OS} eq 'WINDOWS' && $perltype ne 'Cygwin' ) {

    # ActiveState or SiePerl/other
    # FIXME: Advice in this section should be reviewed and tested by people
    # using ActivePerl
    my $perl5shell = $ENV{'PERL5SHELL'} || '';
    $n = $perl5shell.
      NOTE(<<HERE
This environment variable is used by ActiveState and other Win32 Perls to run
commands from TWiki scripts - it determines which shell program is used to run
commands that use 'pipes'.  Examples of shell programs are cmd.exe,
command.com (aka 'DOS Prompt'), and Cygwin's 'bash'
(<strong>recommended</strong> if Cygwin is installed).
<p>
To use 'bash' with ActiveState or other Win32 Perl you should set the
PERL5SHELL environment variable to something like
<tt><strong>c:/YOURCYGWINDIR/bin/bash.exe -c</strong></tt>
This should be set in the System Environment, and ideally set directly in the
web server (e.g. using the Apache <tt>SetEnv</tt> directive).
HERE
          );
    if ($perltype eq 'ActiveState' and 
	    Win32::BuildNumber() < $ActivePerlRecommendedBuild ) {
    	$n .= WARN("ActiveState Perl must be upgraded to build <strong>",
             $ActivePerlRecommendedBuild,
             "</strong> if you are going to use PERL5SHELL, which was broken",
             "in earlier builds.");
    }
    print ROW("PERL5SHELL", $n);
}

# "Parse" TWiki.cfg
my $cfgfile = findFileOnPath("TWiki.cfg");
open(F, $cfgfile);
undef $/;
my $text = <F>;
close(F);
$text =~ s/^# //gm;

my $type;
my $descr;
my $opts;
foreach (split(/\r?\n/, $text)) {
    if( m/^\*\*([A-Z]+)(\s*.*?)\*\*/ ) {
        if( $type eq '_HELP' ) {
            print CGI::Tr(CGI::td({ colspan => 2 }, $descr));
        }
        $type = $1;
        $opts = $2 || '';
        $opts .= ' '; # to simplify parsing
        $descr = '';
    } elsif ($type && /\$(TWiki::)?cfg(.*?)\s*=/) {
        if( $type eq '_HELP' ) {
            print CGI::Tr(CGI::td({ colspan => 2 }, $descr));
        } else {
            print __checkAndBuildValueGrabber($type, $opts, $descr, $2);
        }
        $type = '';
        $descr = '';
    } elsif( m/^##+(.*?)#+$/ ) {
        print CGI::Tr(CGI::td({ colspan => 2 },
                              CGI::a({name=>_makeAnchor( $1 )},
                                     CGI::h2( $1 ))));
        $type = '_HELP';
    } elsif( $type ) {
        $descr .= "$_ ";
    }
}
print CGI::end_table();
print CGI::span({class=>'error'},$errors.' errors') if $errors;
print CGI::span({class=>'warn'},$warnings.' warnings') if $warnings;
print CGI::p(CGI::submit(-onclick=>'verify_mandatory()', -value=>'Update')),
  CGI::end_form();

print CGI::end_html();

# End of code

sub _makeAnchor {
    my $str = shift;

    $str =~ s/\s(\w)/uc($1)/ge;
    $str =~ s/\W//g;
    return $str;
}

# Generates the appropriate HTML for getting a value to configure the
# entry. The opts are additional parameters, and by convention may
# be a number (for a string length), a comma separated list of values
# (for a select) and may also have an M for mandatory. The actual
# input field is decided by the type, which is used to compose a function
# name by prepending _prompt.
#.
# The method also builds a function name by prepending _check to the
# field name, and calls it if it exists to perform additional checking
# for that specific field (see _checkDataDir as an example)
#
sub __checkAndBuildValueGrabber {
    my( $type, $opts, $desc, $keys) = @_;

    my $mandatory = ($opts =~ /\sM\s/);
    # field id
    my $id = $keys;
    $id =~ s/}{/_/g;
    $id =~ s/[{}\[\]]//g;
    my $anchor = CGI::a({name=>$id},'');
    print CGI::hidden(-name => 'TYPEOF:'.$id, -value=>$type);
    my $checker = '_check'.$id;
    if( defined &$checker ) {
        no strict 'refs';
        $desc .= &$checker();
        use strict 'refs';
    }

    my $prompter = '_prompt'.$type;
    my $value = eval '$TWiki::cfg'.$keys;
    no strict 'refs';
    $prompter = &$prompter($id, $opts, $value, $keys, $mandatory);
    my $class = $type;
    $class .= ' mandatory' if $mandatory;
    $prompter = CGI::span({class=>$class}, $prompter) if $mandatory;
    use strict 'refs';

    $desc = $anchor."\n".$desc;

    my $docrow =
      CGI::Tr( CGI::td( { colspan => 2, class=>'docdata info' }, $desc ));

    $keys = CGI::span({class=>'mandatory'}, $keys) if $mandatory;
    my $keyrow =
      CGI::Tr( { class => 'keydata' },
               CGI::td( $keys ).CGI::td( $prompter ));

    return $docrow."\n".$keyrow."\n";
}

sub _promptSTRING {
    my( $id, $opts, $value, $keys ) = @_;
    my $size = 60;
    if( $opts =~ /\s(\d+)\s/ ) {
        $size = $1;
    }
    return CGI::textfield( -name => $id, -size=>$size, -default=>$value );
}

sub _promptURL {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptURLPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptBOOLEAN {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::checkbox( -name => $id, -checked => ( $value ? 1 : 0),
                          -value => 1, -label => '' );
}

sub _promptREGEX {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptCOMMAND {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptNUMBER {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>20, -default=>$value );
}

sub _promptSELECT {
    my( $id, $opts, $value, $keys ) = @_;
    $opts =~ s/^\s+//;
    $opts =~ s/\s.*$//;
    my $sopts = '';
    foreach my $opt (split( /\s*,\s*/, $opts)) {
        if( $opt eq $value ) {
            $sopts .= '<option selected="selected">'.$opt.'</option>';
        } else {
            $sopts .= '<option>'.$opt.'</option>';
        }
    }
    return CGI::Select({ name => $id, size=>1, default=>$value }, $sopts);
}

sub _checkBinDir {
    my $dir = $ENV{SCRIPT_FILENAME} || '.';
    $dir =~ s(/+configure[^/]*$)();
    my $ext = $TWiki::cfg{ScriptSuffix} || '';
    my $errs = '';
    opendir(D, $dir) or return ERROR("Can't open $dir for read");
    foreach my $script (grep { !/(^\.|\.cfg|\.txt)/ } readdir D) {
        next if( $ext && $script !~ /\.$ext$/ );
        if( !-x "$dir/$script" ) {
            $errs .= WARN($script . ' is not executable');
        }
    }
    closedir(D);
    return $dir.'<br />'.$errs;
}

sub _checkDefaultUrlHost {
    my $keys = shift;

    if( $TWiki::cfg{DefaultUrlHost} ) {
        if( $TWiki::cfg{DefaultUrlHost} !~ /$ENV{HTTP_HOST}/ ) {
            return WARN('Current setting does not match HTTP_HOST ',
                        $ENV{HTTP_HOST});
        }
    } else {
        my $protocol = $url || 'http://'.$ENV{HTTP_HOST};
        $protocol =~ s(^(.*?://.*?)/.*$)($1);
        $TWiki::cfg{DefaultUrlHost} = $protocol;
        return WARN('I guessed this setting');
    }
}

sub _checkScriptUrlPath {
    # Check Script URL Path against REQUEST_URI
    my $n;
    my $val = $TWiki::cfg{ScriptUrlPath};
    my $guess = $ENV{REQUEST_URI} || $ENV{SCRIPT_NAME} || '';
    $guess =~ s(/+configure[^/]*$)();

    if( $val ) {
        unless( $guess ) {
            return WARN(<<HERE
This web server does not set REQUEST_URI or SCRIPT_NAME
so it isn't possible to check the correctness of this setting.
HERE
                       );
        };
        if ( $guess !~ /^$val/ ) {
            return WARN('I expected this to look like "'.$guess.'"');
        }
    } else {
        unless( $guess ) {
            return WARN(<<HERE
This web server does not set REQUEST_URI or SCRIPT_NAME
so it isn't possible to guess this setting.
HERE
                       );
        };
        $TWiki::cfg{ScriptUrlPath} = $guess;
        return WARN('I guessed this setting');
    }
}

sub _checkPubUrlPath {
    unless( $TWiki::cfg{PubUrlPath} ) {
        my $guess = $TWiki::cfg{ScriptUrlPath};
        $guess =~ s/bin$/pub/;
        $TWiki::cfg{PubUrlPath} = $guess;
        return WARN('I guessed this setting');
    }
    return 'This is not set correctly if the link below is broken:<br />'.
      '<a href="'.$TWiki::cfg{PubUrlPath}.'">click here</a>';
}

sub _findMajorDir {
    my( $cfg, $dir ) = @_;
    return '' if( $TWiki::cfg{$cfg} );
    my $guess = $ENV{SCRIPT_FILENAME};
    unless( $guess ) {
        return WARN("This web server does not set SCRIPT_FILENAME so I can't guess a value for this");
    }
    $guess =~ s(bin/*configure$)();
    $guess .= $dir;
    $TWiki::cfg{$cfg} = $guess;
    return WARN('I guessed this setting');
}

sub _checkPubDir {
    my $e = _findMajorDir('PubDir', 'pub');
    my $e2 = _checkTreePerms( $TWiki::cfg{PubDir}, 'rw' );
    $e = WARN($e2) if $e2;
    return $e;
}

sub _checkTemplateDir {
    my $e = _findMajorDir('TemplateDir', 'templates');
    my $e2 = _checkTreePerms( $TWiki::cfg{TemplateDir}, 'r' );
    $e .= ERROR($e2) if $e2;
    return $e;
}

sub _checkDataDir {
    my $e = _findMajorDir('DataDir', 'data');
    my $e2 = _checkTreePerms( $TWiki::cfg{DataDir}, "r" );
    $e2 = _checkTreePerms( $TWiki::cfg{DataDir}, "w", qr/\.txt$/ )
      unless $e2;
    $e .= WARN($e2) if $e2;
    return $e;
}

sub _checkMailProgram {
    eval "use Net::SMTP";
    my $n;
    if ($@) {
        $n = "Net::SMTP is <b>not</b> installed in this environment. ";
        my $val = $TWiki::cfg{MailProgram} || '';
        $val =~ s/\s.*$//g;
        if( ! ( -e $val ) ) {
            return WARN("<tt>$val</tt> was not found. Check the path.");
        }
    } else {
        $n = 'Net::SMTP is installed in this environment, so this setting will <b>not</b> be used.';
    }
    return $n;
}

sub _checkLogFileName {
    my $logFile = $TWiki::cfg{LogFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkConfigurationLogName {
    my $logFile = $TWiki::cfg{ConfigurationLogName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkWarningFileName {
    my $logFile = $TWiki::cfg{WarningFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkDebugFileName {
    my $logFile = $TWiki::cfg{DebugFileName} || "";
    $logFile =~ s/%DATE%/DATE/;
    my $e = _checkCanCreateFile( $logFile );
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkMimeTypesFileName {
    my $e = _checkTreePerms($TWiki::cfg{MimeTypesFileName}, 'r');
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkHtpasswd_FileName {
    my $e = _checkTreePerms($TWiki::cfg{Htpasswd}{FileName}, 'r');
    $e = ERROR($e) if $e;
    return $e;
}

sub _checkRemoteUserFileName {
    my $file = $TWiki::cfg{RemoteUserFileName};;
    my $e = _checkCanCreateFile( $file );
    $e = WARN($e) if $e;
    return $e;
}

sub _checkRegistrationApprovals {
    my $file = $TWiki::cfg{RegistrationApprovals};
    my $e = _checkTreePerms( $file, 'rw' );
    $e = WARN($e) if $e;
    return $e;
}

sub _checkUseLocale {
    my $on = $TWiki::cfg{UseLocale};
    my $n = '';
    if( $on && $TWiki::cfg{OS} eq 'WINDOWS' ) {
        # Warn re known broken locale setup
        $n .= WARN(<<HERE
Using Perl on Windows, which may have missing or incorrect locales (in Cygwin
or ActiveState Perl, respectively) - turning off {LocaleRegexes} is
recommended unless you know your version of Perl has working locale support.
HERE
                  );
    }

	# Warn against Perl 5.6 or lower for UTF-8
	if ( $on && $perlvernum < 5.008 ) {
        $n .= WARN("Perl 5.8 is required if you are using TWiki's",
                   "experimental UTF-8 support\n");
    }

    # Check for 'useperlio' in Config on Perl 5.8 or higher - required
    # for use of ':utf8' layer.
    if ( $on && $perlvernum >= 5.008 and 
         not ( exists $Config::Config{useperlio} and
               $Config::Config{useperlio} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled to use PerlIO",
                   "by default ('useperlio' not set in Config.pm, see",
                   "<i>Perl's Unicode Model</i> in 'perldoc perluniintro')",
                   "- re-compilation of Perl will be required before it",
                   "can be used to enable TWiki's experimental UTF-8",
                   "support.");
    }

    # Check for d_setlocale in Config (same as 'perl -V:d_setlocale')
    eval "use Config";
    if ( $on && !( exists $Config::Config{d_setlocale} &&
            $Config::Config{d_setlocale} eq 'define' ) ) {
        $n .= WARN(<<HERE
This version of Perl was not compiled with locale support ('d_setlocale' not
set in Config.pm) - re-compilation of Perl will be required before it can be
used to support TWiki internationalisation.
HERE
                  );
    }
    return $n;
}

sub _checkUpperNational {
    if( $perlvernum < $perlVerPreferred || 1) {
        # Locales are off/broken, or using pre-5.6 Perl, so have to 
        # explicitly list the accented characters (but not if using UTF-8)
        my $forUpperNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;

        if ($forUpperNat) {
            return WARN( <<HERE
The following upper case accented characters have been found in this locale
and should be considered for use in this parameter:
<strong>$forUpperNat</strong>
HERE
                       );
        }
    }
    return '';
}

sub _checkLowerNational {
    if( $perlvernum < $perlVerPreferred || 1) {
        # Locales are off/broken, or using pre-5.6 Perl, so have to 
        # explicitly list the accented characters (but not if using UTF-8)
        my $forLowerNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;

        if ($forLowerNat) {
            return WARN( <<HERE
The following lower case accented characters have been found in this locale
and should be considered for use in this parameter:
<strong>$forLowerNat</strong>
HERE
                       );
        }
    }
    return '';
}

sub _checkSiteLocale {
    my $locale = $TWiki::cfg{SiteLocale};
    # Try to see if required locale was correctly set earlier
    my $currentLocale = setlocale(&LC_CTYPE);
    if ( $currentLocale ne $locale ) {
        return WARN(<<HERE
Unable to set locale to '$locale'. The actual locale is '$currentLocale'
- please test your locale settings. This warning can be ignored if you are
not planning to use locales (e.g. your site uses English only) - or you can
set  <strong>SiteLocale</strong> to <code>C</code>, which should always work.
HERE
                );
    }
    return '';
}

# Since Windows (without Cygwin) makes it hard to capture stderr
# ('2>&1' works only on Win2000 or higher), and Windows will usually have
# GNU tools in any case (installed for TWiki since there's no built-in
# diff, grep, patch, etc), we only check for these tools on Unix/Linux 
# and Cygwin.  
sub checkGnuVersion {
    my $ok = 0;

    my ($progExecString, $progReadableName, $progUsage) = @_;        # Usage is 'used for...' string

    if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
        $progExecString =~ s/\s.*$//;
        my $diffOut = `$progExecString --version 2>&1` || "";
        my $notFound = ( $? == -1 );
        my $n;
        if( $notFound ) {
            $n = WARN("'$progReadableName' program was not found on the",
                       "current PATH.");
        } elsif ( $diffOut !~ /\bGNU\b/ ) {
            # Program found on path, complain if no GNU in version output
            $n = WARN("'$progReadableName' program was found on the PATH",
                       "but is not GNU $progReadableName - this may cause",
                       "problems. $diffOut");
        } else {
            $n = "GNU $progReadableName was found on the PATH -".
                  " this is the recommended $progReadableName tool.";
	    $ok = 1;
        }

        ROW($progReadableName, $n, NOTE("The '$progReadableName' command is $progUsage."));
    }

    return $ok;
}

sub _checkCanCreateFile {
    my $name = shift;
    if (-e $name) {
        return _checkTreePerms($name,'rw');
    }
    my $txt1 = "test 1 2 3";
    unlink $name if( -e $name );
    open( FILE, ">$name" ) ||
      return 'Could not create test file ', $name;
    print FILE $txt1;
    close( FILE);
    open( IN_FILE, "<$name" ) ||
      return 'Could not read test file ', $name;
    my $txt2 = <IN_FILE>;
    close( IN_FILE );
    unlink $name if( -e $name );
    unless ( $txt2 eq $txt1 ) {
        return 'Could not write and then read '.$name;
    }
    return '';
}

sub _checkTreePerms {
    my( $path, $perms, $filter ) = @_;

    return '' if( defined($filter) && $path !~ $filter && !-d $path);

    my $errs = '';

    return $path. ' cannot be found<br />' unless( -e $path );

    if( $perms =~ /r/ && !-r $path) {
        $errs .= ' readable';
    }

    if( $perms =~ /w/ && !-d $path && !-w $path) {
        $errs .= ' writable';
    }

    if( $perms =~ /x/ && !-x $path) {
        $errs .= ' executable';
    }

    return $path.' is not '.$errs.'<br />' if $errs;

    return '' unless -d $path;

    opendir(D, $path) ||
      return 'Directory '.$path.' is not readable.<br />';

    foreach my $e ( grep { !/^\./ } readdir( D )) {
        my $p = $path.'/'.$e;
        $errs .= _checkTreePerms( $p, $perms, $filter );
    }
    closedir(D);
    return $errs;
}

sub _checkScriptSuffix {
    # SMELL: should check to see what the extension on _this_ script
    # is, and generate a helpful message
    return '';
}

sub _checkStoreImpl {
    my $bad = '';
    if( $TWiki::cfg{StoreImpl} eq 'RcsWrap') {
        foreach my $key( %{$TWiki::cfg{RCS}} ) {
            if ( $key && $key =~ /Cmd$/ ) {
                my $proggy = $TWiki::cfg{RCS}{$key} || "";
                $proggy =~ s/\s.*$//;
                if( $proggy) {
                    my $version = `$proggy -V` || '';
                    $version =~ /(\d+(\.\d+)+)/;
                    $version = $1;
                    $proggy .= " (version $version)";
                    $proggy .= " (Cygwin package <tt>rcs-$cygwinRcsVerNum</tt>)" if defined($cygwinRcsVerNum);
                    if( $proggy =~ /\/(rcs|rlog|rcsdiff|co)\b$/ &&
                        $version && $version < $rcsverRequired ) {
                        # RCS too old
                        $bad .= ERROR($proggy.' is too old, upgrade to version $rcsverRequired or higher.');
                    }
                }
            }
        }
    }

    if( $bad ) {
        $bad .= <<HERE;
TWiki will not work with this RCS setup. Either correct the setup, or
switch to RcsLite. To enable RCSLite you need to change the setting of
{StoreImpl} to 'RcsLite'.
HERE
        return $bad;
    }
    return '';
}

sub H3 {
    my $text = join("\n",@_);
    return CGI::Tr(CGI::th({align=>'left', valign=>'top', colspan=>'2'},
                           CGI::h3($text)));
}

sub H2 {
    my $text = join("\n",@_);
    return CGI::Tr(CGI::th({align=>'left', valign=>'top', colspan=>'2'},
                           CGI::h2($text)));
}

sub ROW {
    my $left = shift;
    my $right = join("\n", @_);
    return CGI::Tr(CGI::th({ class => 'keydata' },$left), CGI::td($right));
}

# a note
sub NOTE {
    return CGI::p({class=>"info"}, join("\n",@_));
}

# a warning
sub WARN {
    $warnings++;
    return CGI::p({class=>'warn'}, CGI::strong('Warning: ').join("\n",@_));
}

# an error
sub ERROR {
    $errors++;
    return CGI::p({class=>'error'}, CGI::strong('Error: ').join("\n",@_));
}

sub findFileOnPath {
    my $file = shift;
    $file =~ s(::)(/)g;

    foreach my $dir ( @INC ) {
        if( -e "$dir/$file" ) {
            return "$dir/$file";
        }
    }
    return undef;
}

sub setConfig {
    my $updates = shift;
    my $lsc = findFileOnPath('LocalSite.cfg');
    unless( $lsc ) {
        $lsc = findFileOnPath('TWiki.cfg');
        die "Can't find key twiki components" unless $lsc;
        $lsc =~ s/TWiki\.cfg/LocalSite.cfg/;
    }
    open(F, "<$lsc") ||
      die "Failed to open $lsc for read";
    undef $/;
    my $txt = <F>;
    close(F);

    foreach my $config ( keys %$updates ) {
        # kill the old settings if any are there
        $txt =~ s/\$TWiki::cfg\{$config\}\s*=.*?;//s;
    }

    open(F, ">$lsc") ||
      die "Failed to open $lsc for write";
    print F $txt if $txt;
    foreach my $config ( keys %$updates ) {
        print F '$TWiki::cfg{',$config,'} = ',$updates->{$config},";\n";
    }
    close(F);

    if( defined( $TWiki::cfg{ConfigurationLogName} ) &&
        open(F, '>>'.$TWiki::cfg{ConfigurationLogName} )) {
        my $date = gmtime();
        my $user = $query->remote_user() || 'guest';
        foreach my $config ( keys %$updates ) {
            print F '| ',$date,' | ',$user,' | ',$config,' | ',
              $updates->{$config}," |\n";
        }
        close(F);
    }
}

sub perlifyType {
    my ($val,$type) = @_;

    if ($type eq 'REGEX') {
        return "qr($val)";
    } elsif ($type eq 'BOOLEAN') {
        return ($val ? 1 : 0);
    } elsif ($type eq 'NUMBER') {
        return 0+$val;
    } else {
        $val =~ s/'/\\'/g;
        return "'$val'";
    }
}

1;
