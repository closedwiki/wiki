#!/usr/bin/perl -w
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at 
# http://www.gnu.org/copyleft/gpl.html
#
# Configuration script for TWiki. Once you have a basic webserver
# configuration that lets you access this script, the rest of the
# configuration process is done from here. This script replaces
# the old "testenv" script.
#
# The script works by accepting values into a CGI form, and then
# submitting those values back to itself with a parameter (update)
# set to 1. This causes it to write config changes to LocalSite.cfg.
# Note that changes are only written if there is a real change in the
# value.
#
# The values available to configuration are determined by parsing
# TWiki.cfg. Special full-line comments guide the parse:
# Any comment of the form
######## Some text #########
# is taken as a H2 heading, and following comments are dragged in too.
# Comments of the form
# **TYPE opts**
# where TYPE is one of URL, PATH, URLPATH, BOOLEAN, STRING, REGEX, SELECT
# are used to indicate that a following cfg var is configurable through
# the interface. All intermediate comments are taken as documentation for
# the value.
#
package TWiki;

# BASIC checks. Without these, nothing works.

use strict;
my $setlibAvail;
my $brokenTWikiCfg;
my $brokenTWikiCfgError;
my $brokenLocalSiteError;
my %cfg; # TWiki config
my $OS;
my $detailedOS;
my $cygwinRcsVerNum;
my $perlverRequired = 5.00503;		# Oldest supported version of Perl
my $perlverRequiredString = '5.005_03';
my $perlverRecommended = '5.6.1';
my $ActivePerlRecommendedBuild = 631;	# Fixes PERL5SHELL bugs

# CGI.pm version, on some platforms - actually need CGI 2.93 for mod_perl
# 2.0 and CGI 2.90 for Cygwin Perl 5.8.0.  See 
# http://perl.apache.org/products/apache-modules.html#Porting_CPAN_modules_to_mod_perl_2_0_Status
my $cgiModVerRecommended = '2.93';	

# Recommended mod_perl version if using mod_perl 2.0 (see Support.RegistryCookerBadFileDescriptor)
my $modPerlVersionRecommended = '1.99_12';	

my $rcsverRequired = 5.7;
use vars qw( $TRUE $FALSE);

#local $SIG{__DIE__} = sub { Carp::confess $_[0] };

BEGIN {
    $TRUE = 1;
    $FALSE = 0;
    # Set default current working directory
    if( $ENV{"SCRIPT_FILENAME"} && $ENV{"SCRIPT_FILENAME"} =~ /^(.+)\/[^\/]+$/ ) {
        chdir $1;
    }

    # Required for testenv to work
    my %basicMods =
      (
       'CGI'       => "basic TWiki",
       'CGI::Carp' => "basic TWiki"
      );

    $| = 1;                  # no buffering - FIXME: mod_perl issue?

    # Check whether basic CGI modules exist (some broken installations of
    # Perl don't have this, even though they are standard modules), and warn user
    my $modMissing = 0;
    foreach my $mod (keys %basicMods) {
        eval "use $mod";
        if ($@) {
            unless ($modMissing) {
                print 'Content-Type: text/plain'."\n\n";
                print 'Perl Module(s) missing';
            }
            $modMissing = 1;
            print 'Warning: Essential module ',$mod;
            print 'not installed - please check your Perl installation, ',
              'including the setting of @INC, and re-install Perl if necessary.';
        }
    }

    # If any critical modules missing, display @INC and give up 
    if ($modMissing) {
        print '@INC setting:', join(' ', @INC);
        exit;
    }

    # Set library paths in @INC, read TWiki.cfg and set locale, at compile time
    # Try to use setlib.cfg, use default path if missing
    if ( -r './setlib.cfg' ) {
        require './setlib.cfg'; 
        $setlibAvail = 1;
    } else {
        unshift @INC, '../lib';
        $setlibAvail = 0;
    }
    if( $OS ) {
        $TWiki::cfg{DetailedOS} = $detailedOS;
        $TWiki::cfg{OS} = $OS;
    } else {
        # SMELL: duplicates code in TWiki.pm
        unless( ( $TWiki::cfg{DetailedOS} = $^O ) ) {
            require Config;
            $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
        }
        $TWiki::cfg{OS} = 'UNIX';
        if ($TWiki::cfg{DetailedOS} =~ /darwin/i) { # MacOS X
            $TWiki::cfg{OS} = 'UNIX';
        } elsif ($TWiki::cfg{DetailedOS} =~ /Win/i) {
            $TWiki::cfg{OS} = 'WINDOWS';
        } elsif ($TWiki::cfg{DetailedOS} =~ /vms/i) {
            $TWiki::cfg{OS} = 'VMS';
        } elsif ($TWiki::cfg{DetailedOS} =~ /bsdos/i) {
            $TWiki::cfg{OS} = 'UNIX';
        } elsif ($TWiki::cfg{DetailedOS} =~ /dos/i) {
            $TWiki::cfg{OS} = 'DOS';
        } elsif ($TWiki::cfg{DetailedOS} =~ /^MacOS$/i) { # MacOS 9 or earlier
            $TWiki::cfg{OS} = 'MACINTOSH';
        } elsif ($TWiki::cfg{DetailedOS} =~ /os2/i) {
            $TWiki::cfg{OS} = 'OS2';
        }
    }

    # if this fails, ignore the problem, but we have to do it
    unless( eval 'do "LocalSite.cfg"' ) {
        # Capture the Perl error(s)
        $brokenLocalSiteError = 'require failed: '.
          ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
    }

    # Read the configuration file now in order to set locale;
    # includes checking for broken syntax etc.  Need 'require'
    # to get the $!/$@ to work.
    $brokenTWikiCfg = 0;
    unless( eval 'require "TWiki.cfg" ' ) {
        # Capture the Perl error(s)
        $brokenTWikiCfgError = 'require failed: '.
          ( $! ? $!.'<br />' : '') . ( $@ ? $@.'<br />' : '');
    }

    # and again
    eval 'do LocalSite.cfg';

    # Do a dynamic 'use locale' for this script
    if( $TWiki::cfg{UseLocale} ) {
        require locale;
        import locale ();
    }
}

my $query = new CGI;
my $url = $query->url();
my $update = $query->param('update');

print CGI::header('text/html'),
  CGI::start_html(),
  CGI::title('TWiki Configuration'),
  CGI::style( { type=>'text/css', media=>'all' }, <<'HERE'
		html body {
			line-height:1.55em;
			font-family:Avenir, "Lucida Grande", "Bitstream Vera Sans", lucida, arial, verdana, sans-serif;
			background-color:#C3C3C3;
			margin:0;
			padding:0;
		}
		h1 {
		    font-size:210%;
		    background-color:#C3C3C3;
		    padding:0.2em 0.7em;
		    color:#C90000;
		    margin:1em -0.7em 0.15em -0.7em;
		}
		h2 {
		    background-color:#F0F0F0;
		    padding:2ex 0.7em 0.2em 0.7em;
		}
		h3 {
		    padding:0.2em 0.7em;
		}
        .info {
            color: green;
        }
        .warn {
			color:orange;
        }
        .error {
			color:red;
            font-weight: bold;
        }
        .mandatory {
			color:red;
            font-weight: bold;
        }
		.twikiMain {
			padding:0em 3.5em 2em;
			margin-top:2.5em;
			margin-right:2.5em;
			margin-left:2.5em;
			margin-bottom:2.5em;
			background-color:white;
			border-width:4px;
			border-style:ridge;
			border-color:#484848 #dddddd #818181 #A6A6A6;
		}
        .docdata {
            padding-top: 1ex;
        }
        .keydata {
            font-weight: bold;
			background-color:#FOFOFO;
        }
HERE
            ), '<div class="twikiMain">';

if( $update ) {
    print CGI::h1('Updating configuration');
    my $changed = 0;
    my %updates;
    foreach my $param ( $query->param ) {
        my $basevar = $param;
        $basevar =~ s/_/}{/g;
        my $var = '$TWiki::cfg{'.$basevar.'}';
        my $def;
        eval "\$def = defined( $var );";
        if( $def ) {
            eval "\$def = $var;";
            my $val = $query->param( $param );
            if( $val eq $def) {
                #print CGI::br($var.' is unchanged');
                next;
            } else {
                my $type = $query->param('TYPEOF:'.$param);
                print CGI::h2($var),
                  CGI::b('old ').CGI::code($def).
                      CGI::br(CGI::b('new  ').CGI::code($val));
                $updates{$basevar} = perlifyType($val,$type);
                $changed++;
            }
        }
    }
    print CGI::p();
    setConfig(\%updates);
    print $changed.' configuration items changed. ';
    print CGI::a({ href=>$url }, 'Click here to return to configuration');
    exit 1;
}

# use strict;		# Recommended for mod_perl, enable for Perl 5.6.1 only
# Doesn't work well here, due to 'do "TWiki.cfg"'
# use diagnostics;	# Debug only

if ($brokenTWikiCfgError) {
    print CGI::h3("Configuration error");
    print CGI::h2('WARNING:');
    print 'TWiki.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) should help locate the problem.<p />';
    print $brokenTWikiCfgError;

    # EARLY EXIT
    print CGI::end_html();
    exit;
}

if ($brokenLocalSiteError) {
    print CGI::h3('Configuration error'),
      CGI::h2('WARNING:'),
          'LocalSite.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) should help locate the problem.<p />',
            $brokenLocalSiteError, CGI::end_html();
    exit;
}

my %requiredMods =
  (
   'File::Copy' => 'basic TWiki',
   'File::Spec' => 'basic TWiki',
   'FileHandle' => 'basic TWiki',
  );

# Required on non-Unix platforms (mainly Windows)
my %requiredModsNonUnix =
  (
   'Digest::SHA1' => "register script",
   'MIME::Base64' => "register script",
   'Net::SMTP'    => "registration emails and mailnotify",
  );

# Optional modules on all platforms
my %optionalMods =
  (
   'MIME::Base64'     => "HTTP Authentication to proxies (CPAN)",
   'POSIX'            => "I18N (core module) and Security",
   'Digest::MD5'      => "MD5 encoded passwords",
   'Encode'           => "I18N conversions (core module in Perl 5.8)",
   'Unicode::MapUTF8' => "I18N conversions (CPAN)",
   'Unicode::Map'     => "I18N conversions (CPAN)",
   'Unicode::Map8'    => "I18N conversions (CPAN)",
   'Jcode'            => "I18N conversions (CPAN)",
  );

# Load CGI modules (run-time, after checking they are accessible)
require CGI;
import CGI qw( -any );
require CGI::Carp;
import CGI::Carp qw( fatalsToBrowser );


print  <<HERE;
<h1> TWiki Test Environment </h2>
This page is used to set up the configuration options for TWiki. Settings
marked <span class='mandatory'>like this</span> are required (they must
have a value). Fill in the settings, and then select 'Update'.
TWiki will be reconfigured and you will be returned to this page. Any
errors in your configuration will be <font color="red">highlighted</font>.
<p />
If you are installing TWiki for the first time, and you are on a
Unix or Linux platform and behind a firewall, the only section you
should need to worry about below is "General path settings".
<p />
If you are on a public site, you will need to consider carefully
how you are going to manage authentication and access control.
<p />
There are a number of documentation topics describing how to
configure TWiki for different platforms, and a lot of support
available at TWiki.org. The configuration settings currently in
use can be managed using the 'configure' script.

If your TWiki site is working, the front page should be
<a href="$TWiki::cfg{ScriptUrlPath}/view$TWiki::cfg{ScriptSuffix}">right here</a>
HERE

print CGI::start_form({ action=>'configure',method=>"post" }),
  CGI::start_table();

print CGI::hidden(-name=>'update',-value=>'1');

print H2('Environment variables');
for my $key ( sort keys %ENV ) {
    print CGI::Tr( CGI::th($key).CGI::td($ENV{$key}));
}

print H2('CGI Setup');
# Make %ENV safer for CGI (should reflect TWiki.pm)
my $originalPath = $ENV{'PATH'} || '';
if( $TWiki::cfg{SafeEnvPath} ) {
    $ENV{'PATH'} = $TWiki::cfg{SafeEnvPath};
}
delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

# Get Perl version - output looks neater with new variable
my $perlvernum = $];
my $perlver;
if (defined $^V) {
    $perlver = $^V;             # New in Perl 5.6.1, one byte per part
    $perlver = ord(substr($perlver,0)) . "." . ord(substr($perlver,1))
                                       . "." . ord(substr($perlver,2));
} else {
    $perlver = $perlvernum
}
my $perlverMsg = $perlver;		# Default version message

# Load Config module - used here and elsewhere
require Config;

# Set $TWiki::cfg{DetailedOS} if not using later versions of TWiki.cfg for BeijingRelease
# - this code enables the latest testenv to be used with Dec 2001 and 
# earlier releases.
if ( !defined $TWiki::cfg{DetailedOS} ) {
    $TWiki::cfg{DetailedOS} = $Config::Config{'osname'};
}

# Detect Perl flavour on Windows, and Cygwin Perl/RCS package versions
use vars qw($perltype);

if ($TWiki::cfg{DetailedOS} eq 'cygwin') {
    $perltype = 'Cygwin';				# Cygwin Perl only
    my ($pkg, $pkgName);

    # Get Cygwin perl's package version number
    $pkgName = 'perl';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$perlverMsg = $perlver . $pkg
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$perlverMsg = $pkg;
    }
	
    # Get Cygwin RCS's package version number
    $pkgName = 'rcs';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$cygwinRcsVerNum = $pkg;	
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$cygwinRcsVerNum = $pkg;	
    }
} elsif ($TWiki::cfg{DetailedOS} =~ /win/i && $TWiki::cfg{DetailedOS} !~ /darwin/i ) {
    # Windows Perl - try ActivePerl-only function: returns number if
    # successful, otherwise treated as a literal (bareword).
    my $isActivePerl= eval 'Win32::BuildNumber !~ /Win32/';
    if( $isActivePerl ) {
	$perltype = 'ActiveState';
        $perlverMsg = $perlver . ", build " . Win32::BuildNumber();
    } else {
	# Could be SiePerl or some other Win32 port of Perl
	$perltype = 'SiePerl or other Windows Perl';
    }
} else {
    $perltype = 'generic';
}

# Detect executable name suffix, e.g. .exe on Windows or '' on Unix
# Avoid testing for .exe suffixes on Cygwin, since the built-in
# grep and ls don't end in '.exe', even though Perl's '_exe' setting
# indicates they should.
my $exeSuffix='';
if ( $Config::Config{'_exe'} and ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype ne 'Cygwin') ) { 
    if ( ! $ENV{'INTERIX_ROOT'} ) { #this is set is we are using UnixServicesForWindows (or INTERIX funnily enough) and they don't use .exe either
        $exeSuffix = $Config::Config{'_exe'};
    }
}

# Detect whether mod_perl was loaded into Apache
my $modPerlLoaded = ( exists $ENV{'SERVER_SOFTWARE'} && 
			  ( $ENV{'SERVER_SOFTWARE'} =~ /mod_perl/ ));
# Detect whether we are actually running under mod_perl
# - test for MOD_PERL alone, which is enough.
my $usingModPerl = ( exists $ENV{'MOD_PERL'} );
my $modPerlVersion;

# Get the version of mod_perl if it's being used
if ( $usingModPerl ) {
    $modPerlVersion = eval 'use mod_perl; return $mod_perl::VERSION';
}

my $n = ucfirst(lc($TWiki::cfg{OS}));
$n .= " ($TWiki::cfg{DetailedOS})" if ( $TWiki::cfg{DetailedOS} ne '' );
# OS
print ROW("Operating system", $n);

# Perl version and type
$perlverMsg .= " ($perltype)" if $perltype ne 'generic';
print ROW("Perl version", $perlverMsg);

if ( $perlvernum < $perlverRequired ) {
    print ROW('', WARN(<<HERE
This version of Perl is too old for use with TWiki -
upgrade to at least Perl $perlverRequiredString
and preferably to Perl $perlverRecommended.
HERE
                      ));
}

# Perl @INC (lib path)
print ROW('@INC library path', join('<br />', @INC ), NOTE(<<HERE
This is the Perl library path, used to load TWiki modules,
third-party modules used by some plugins, and Perl built-in modules.
HERE
         ));


# Turn off fatalsToBrowser while checking module loads, to avoid load errors in
# browser in some environments.  
$CGI::Carp::WRAP = $CGI::Carp::WRAP = 0;	# Avoid warnings...

# Add to list of required modules if non-Unix, or MacOS X (detected by
# Perl as 'Darwin') - $TWiki::cfg{DetailedOS} is set in TWiki.cfg.
$TWiki::cfg{DetailedOS} ||= $TWiki::cfg{DetailedOS};

# Check that the TWiki.pm module can be found
my $mod = 'TWiki';
eval "require $mod";
my $twikiFound = 0;
my $mess = '';
if ($@) {
    $mess = WARN("'$mod.pm' not found - check path to <code>twiki/lib</code>",
         "and edit <code>twiki/bin/LocalLib.cfg</code> if necessary");
} else {
    $twikiFound = 1;
    my $mod_version = eval '$TWiki::wikiversion || $TWiki::VERSION';
    $mod_version ||= 'unknown';
    $mess = "OK, $mod.pm found (Version: <strong>$mod_version</strong>)";
}
print ROW('TWiki module in @INC path', $mess);

# Do locale settings if TWiki.pm was found
my $showLocales = 0;
if ($twikiFound) {
    if( eval 'TWiki::_setupLocale()' ){	# Not in older TWiki.pm versions
        # Ignore errors silently
        $showLocales = 1;
    }
}

if ( defined $TWiki::cfg{DetailedOS} and ($TWiki::cfg{DetailedOS} =~ /darwin/i or $TWiki::cfg{OS} ne 'UNIX') ) {
    map { $requiredMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
} else {
    # these are optional on Unix
    map { $optionalMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
}

# Check that each of the required Perl modules can be loaded, and
# print its version number.
print H3("Required Perl modules");
foreach my $mod (keys %requiredMods) {
    eval "use $mod";
    if ($@) {
        print ROW($mod, ERROR("not installed. Required for ",
                              $requiredMods{$mod}));
    } else {
        my $mod_version;
        no strict 'refs';
        eval '$mod_version = ${'.$mod.'::VERSION}';
        use strict 'refs';
        $n = $mod_version || 'unknown';
        # Check for potential CGI.pm module upgrade 
        if( $mod eq 'CGI' and $mod_version < $cgiModVerRecommended ) {
            if ( $perltype eq 'Cygwin' and $perlver eq '5.8.0' ) {
                # Recommend CGI.pm upgrade if using Cygwin Perl 5.8.0 
                $n .= WARN( "CGI.pm version $cgiModVerRecommended or higher",
                            "is recommended to avoid problems with attachment",
                            "uploads on Cygwin Perl $perlver.");
            } elsif ( $usingModPerl and $modPerlVersion >= 1.99 ) {
                # Recommend CGI.pm upgrade if using mod_perl 2.0, which
                # is reported as version 1.99 and implies Apache 2.0
                $n .= WARN("CGI.pm version $cgiModVerRecommended or higher is",
                           "recommended to avoid problems with mod_perl version",
                           "$modPerlVersion on Apache 2.0 or higher.");
            }
        }
        print ROW($mod, $n);
    }
}

# Check that each of the optional Perl modules can be loaded, and
# print its version number.
print H3("Optional Perl modules");
foreach $mod (keys %optionalMods) {
    eval "use $mod";
    if ($@) {
        $n = WARN('not installed. May be required for ',
                  $optionalMods{$mod});
    } else {
        my $mod_version;
        no strict 'refs';
        eval '$mod_version = ${'.$mod.'::VERSION}';
        use strict 'refs';
        $n = $mod_version || 'unknown';
    }
    print ROW($mod, $n);
}

# All module checks done, OK to enable fatalsToBrowser
import CGI::Carp qw( fatalsToBrowser );

# PATH_INFO 
print ROW('PATH_INFO', $query->path_info(),
          NOTE(<<HERE
For a URL such as <strong>$url/foo/bar</strong>,
the correct PATH_INFO is <strong>/foo/bar</strong>, without any prefixed path
components. <a href="$url/foo/bar#PATH_INFO">
<strong>Test this now</strong></a>
- particularly if you are using mod_perl, Apache or IIS, or are using
a web hosting provider.
The page resulting from the test link should have a PATH_INFO of
<strong>/foo/bar</strong>
HERE
                        ));

# mod_perl 
my $usingModPerlText = $usingModPerl ? "Used" : "Not used";
my $modPerlLoadedText = ( $modPerlLoaded ? "loaded" : "not loaded" );

$n = "$usingModPerlText for this script (mod_perl $modPerlLoadedText into Apache)\n";
if ( $modPerlVersion ) {
    $n .= "- mod_perl version $modPerlVersion\n";
}
print ROW('mod_perl', $n);

# Check for a broken version of mod_perl 2.0
if ( $usingModPerl and $modPerlVersion >= 1.99 
        and $modPerlVersion eq '1.99_11' ) {
    # Recommend mod_perl upgrade if using a mod_perl 2.0 version
    # with PATH_INFO bug (see Support.RegistryCookerBadFileDescriptor)
    print ROW('', WARN(<<HERE
mod_perl version $modPerlVersionRecommended or higher,
is strongly recommended to avoid 'internal system error'
bugs with PATH_INFO when using mod_perl $modPerlVersion
and Apache 2.0 or higher.
HERE
                      ));
}


# Get web server's user and group info
my $usr = "";
my $grp = "";
if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
    $usr = lc( getpwuid($>) );		# Unix/Cygwin Perl - effective UID
    $grp = join(',', map { lc(getgrgid( $_ )) } split( " ", $( ) );
} else {				# ActiveState or other Win32 Perl
    $usr = lc( getlogin );
    # Try to use Cygwin's 'id' command - may be on the path, since Cygwin
    # is probably installed to supply ls, egrep, etc - if it isn't, give up.
    # Run command without stderr output, to avoid CGI giving error.
    # Get names of primary and other groups.
    $grp = lc(qx(sh -c '( id -un ; id -gn) 2>/dev/null' 2>nul ));
    if ($?) { 
        $grp = "[Can't identify groups - no Cygwin 'id' or 'sh' command on path]";
    }
}

print ROW('CGI user', 'userid = <strong>'.$usr.'</strong> groups = <strong>'.
          $grp.'</strong>'.
          NOTE('Your CGI scripts are executing as this user.'));

H2("Configuration");

$n = "This is used to initialise the PATH variable, and is used to run the".
  " 'diff' program used by RCS, as well as to run shell programs such as ";
if( $TWiki::cfg{OS} eq 'WINDOWS' ) {
    $n .= " cmd.exe or Cygwin's 'bash'.<p>";
    if( $perltype eq 'Cygwin' ) {
        $n .= "Since you are using Cygwin Perl, 'bash' will be used without any special setup.";
    } elsif( $perltype eq 'ActiveState' ) {
        $n .= "To use 'bash' with ActiveState Perl, see the PERL5SHELL section below\n";
        $n .= "- this is recommended if Cygwin is installed.\n";
    }
    $n .= "</p>";
} else {
    $n .= "Bourne shell or 'bash'.";
}
if( !$TWiki::cfg{SafeEnvPath} ) {
    $n .= WARN("Security issue: <strong>SafeEnvPath</strong> set to empty string.");
}
print ROW("SafeEnvPath", $TWiki::cfg{SafeEnvPath}, NOTE($n));

# Generate a separate table about specific environment variables
H2("Path and Shell Environment");

# Check PATH

print ROW("Original PATH", $originalPath,
          NOTE(<<HERE
This is the PATH value passed in from the web server to this
script - it is reset by TWiki scripts to the PATH below, and
is provided here for comparison purposes only.
HERE
              ));

my $currentPath = $ENV{'PATH'} || ''; 	# As re-set earlier in this routine
print ROW("Current PATH", $currentPath,
          NOTE(<<HERE
This is the actual PATH setting that will be used by Perl to run 
programs. It is normally identical to <strong>SafeEnvPath</strong>, unless
that variable is empty.
HERE
              ));


# Check that GNU egrep is found in PATH
my $egrepOk = checkGnuVersion( $TWiki::cfg{RCS}{EgrepCmd}, "egrep", "used for regular expression searches" );

# Check that GNU fgrep is found in PATH
my $fgrepOk = checkGnuVersion( $TWiki::cfg{RCS}{FgrepCmd}, "fgrep", "used for non-regular expression searches" );

unless ( $egrepOk && $fgrepOk ) {
    print ROW('',  NOTE( qq{<a href="http://www.gnu.org/software/grep/grep.html" >grep</a> can be downloaded from <a href="http://www.gnu.org/">GNU</a>'s <a href="ftp://ftp.gnu.org/pub/gnu/grep/" >FTP</a> site} ));
}

# Check that GNU diff is found in PATH
checkGnuVersion( "diff", "diff", "used by RCS to compare files" );

# Check that GNU patch is found in PATH 
checkGnuVersion( "patch", "patch", "used by the UpgradeTwiki script to upgrade an existing TWiki installation" );

# PERL5SHELL check for non-Cygwin Perl on Windows only
if( $TWiki::cfg{OS} eq 'WINDOWS' && $perltype ne 'Cygwin' ) {

    # ActiveState or SiePerl/other
    # FIXME: Advice in this section should be reviewed and tested by people
    # using ActivePerl
    my $perl5shell = $ENV{'PERL5SHELL'} || '';
    $n = $perl5shell.
    NOTE("This environment variable is used by ActiveState and other",
         "Win32 Perls to run \n",
         "commands from TWiki scripts - it determines which shell\n",
         "program is used to run commands that use 'pipes'.  Examples",
         "of shell programs are \n",
         "cmd.exe, command.com (aka 'DOS Prompt'), and Cygwin's 'bash'\n",
         "(<strong>recommended</strong> if Cygwin is installed).\n",
         "<p>\n",
         "To use 'bash' with ActiveState or other Win32 Perls,",
         "you should set the \n",
         "PERL5SHELL environment variable to something like ",
         "<tt><strong>c:/YOURCYGWINDIR/bin/bash.exe -c</strong></tt>.",
         "This should be set in the System Environment, and ideally set \n",
         "directly in the web server (e.g. using the Apache <tt>SetEnv</tt>",
         "command, followed by an Apache restart). Once this is done, you",
         "should re-run <strong>testenv</strong>\n",
         "to check that PERL5SHELL is set properly.\n");
    if ($perltype eq 'ActiveState' and 
	    Win32::BuildNumber() < $ActivePerlRecommendedBuild ) {
    	$n .= WARN("ActiveState Perl must be upgraded to build <strong>",
             $ActivePerlRecommendedBuild,
             "</strong> if you are going to use PERL5SHELL, which was broken",
             "in earlier builds.");
    }
    print ROW("PERL5SHELL", $n);
}

# User authentication and password handling (only if TWiki::User loaded)
if( defined $TWiki::cfg{HtpasswdFormatFamily} ) {
    H2("User Authentication");

    $TWiki::htpasswdEncoding = $TWiki::cfg{HtpasswdEncoding};
    print "</td></tr>\n";
    print ROW("htpasswd Format Family", $TWiki::cfg{HtpasswdFormatFamily});
    print ROW("htpasswd Encoding", $TWiki::cfg{HtpasswdEncoding});
    print ROW("htpasswd Filename", $TWiki::cfg{HtpasswdFilename});
    H3(NOTE("Only some combinations of Format, Encoding and Filename are",
         " valid, and fewer are tested"));
}

# Generate a separate table for locale setup
if ( $showLocales ) {		# Only if TWiki.pm found
    H2("Internationalisation and Locale Setup");

    # $TWiki::cfg{UseLocale}
    $n = $TWiki::cfg{UseLocale}.
     NOTE("This setting controls whether locales are used by Perl and 'grep'");

    if( $TWiki::cfg{OS} eq 'WINDOWS' ) {
        # Warn re known broken locale setup
        $n .= WARN("Using Perl on Windows, which may have missing or",
                   "incorrect locales (in Cygwin or ActiveState Perl,",
                   "respectively) - use of <strong>LocaleRegexes</strong> = 0",
                   "(see below) is recommended unless you know your",
                   "version of Perl has working locale support.");
    }

    # Check for d_setlocale in Config (same as 'perl -V:d_setlocale')
    eval "use Config"; 
    if ( not ( exists $Config::Config{d_setlocale} and $Config::Config{d_setlocale} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled with locale",
                   "support ('d_setlocale' not set in Config.pm)",
                   "- re-compilation of Perl will be required before",
                   "it can be used to support TWiki internationalisation.");
    }
    print ROW("UseLocale", $n);

    $n = $TWiki::cfg{SiteLocale}.
    NOTE("This sets the site-wide locale - for example,",
         "<strong>de_AT.ISO-8859-1</strong> where 'de' is the language code,",
         "'AT' the country code and 'ISO-8859-1' is the character set.",
         "Use the <code>locale -a</code> command on your system to",
         "determine available locales.");

    # Try to see if required locale was correctly set earlier
    my $currentLocale = setlocale(&LC_CTYPE);
    if ( $currentLocale ne $TWiki::cfg{SiteLocale} ) {
        $n .= WARN("Unable to set locale to '$TWiki::cfg{SiteLocale}'. The",
                   "actual locale is '$currentLocale'",
                   "- please test your locale settings. This warning can",
                   "be ignored if you are not planning to use locales (e.g.",
                   "your site uses English only) - or you can set ",
                   "<strong>SiteLocale</strong> to <code>C</code>, which should",
                   "always work.");
    }
    print ROW("SiteLocale", $n);

    # $siteCharset (computed in TWiki::setupLocale from TWiki.cfg settings)
    if (not defined $TWiki::cfg{SiteCharsetOverride} ) {
        $TWiki::cfg{SiteCharsetOverride} = '';
    }

    $n = $TWiki::cfg{SiteCharsetOverride}.
      NOTE(<<HERE
This only needs to be set if the calculated charset, which is derived from
the site-wide locale setting, is wrong. This setting is used in HTML pages
and HTTP headers, so it must be acceptable to web browsers
even if it is different to the locale-derived setting
(e.g. 'euc-jp' instead of 'eucjp')
HERE
          );

	# Warn against Perl 5.6 or lower for UTF-8
	if ( $perlvernum < 5.008 ) {
        $n .= WARN("Perl 5.8 is required if you are using TWiki's",
                   "experimental UTF-8 support\n");
    }

    # Check for 'useperlio' in Config on Perl 5.8 or higher - required
    # for use of ':utf8' layer.
    if ( $perlvernum >= 5.008 and 
         not ( exists $Config::Config{useperlio} and
               $Config::Config{useperlio} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled to use PerlIO",
                   "by default ('useperlio' not set in Config.pm, see",
                   "<i>Perl's Unicode Model</i> in 'perldoc perluniintro')",
                   "- re-compilation of Perl will be required before it",
                   "can be used to enable TWiki's experimental UTF-8",
                   "support.");
    }
    print ROW("SiteCharsetOverride", $n);

    $n = $TWiki::cfg{LocaleRegexes}.
    NOTE("This setting (default: 1) controls whether\n",
         "locale-dependent regular expressions (e.g. <code>[:upper:]</code>) are\n",
         "used by Perl and 'grep'. It is used in environments where locales are\n",
         "broken, to allow use of internationalised WikiWords.  You should\n",
         "configure <strong>UseLocale</strong> to 1, and set a reasonable\n",
         "<strong>SiteLocale</strong>, since this enables correct setting of the\n",
         "site charset for use by web browsers. Don't change this\n",
         "setting unless your locales are not working for whatever reason\n");
    print ROW("LocaleRegexes", $n);

    # Locales are off/broken, or using pre-5.6 Perl, so have to 
    # explicitly list the accented characters (but not if using UTF-8)
    my $perlVerPreferred = 5.006;	# 5.6 or higher has [:lower:] etc
    if ( !$TWiki::cfg{UseLocale} || $perlvernum < $perlVerPreferred
         || !$TWiki::cfg{LocaleRegexes} ) {

        # Can't use locales, so generate upper and lower case character
        # classes to avoid doing this at run-time in TWiki.
        my $forUpperNat;
        my $forLowerNat;
        if ( $perlvernum < $perlVerPreferred ) {
            # Get strings with the non-ASCII alphabetic characters only, upper and lower case
            $forUpperNat = join '', grep { lc($_) ne $_ and m/[^A-Z]/ } map { chr($_) } 1..255;
            $forLowerNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;
        }

        unless( $TWiki::cfg{UseLocale} && $TWiki::cfg{LocaleRegexes} ) {
            $n = $TWiki::cfg{UpperNational}.
              NOTE("This setting is used when <strong>UseLocale</strong> is 0 or",
                   "<strong>LocaleRegexes</strong> is 0, to work around missing or",
                   "non-working locales.\n",
                   "It is also used with Perl 5.005 for efficiency reasons",
                   "- upgrading to Perl 5.6.1 with working locales is",
                   "recommended, and removes the need for this. \n",
                   "If required, it should be set to the upper case accented",
                   "characters you require in your locale.");
            if ( $forUpperNat ) {
                $n .= NOTE("The following upper case accented characters have",
                           "been found in this locale and should be considered",
                           "for use in this parameter: <strong>$forUpperNat</strong>");
            }
            print ROW("UpperNational", $n);
            $n = $TWiki::cfg{LowerNational}.
              NOTE("This setting is used whenever <strong>UpperNational</strong> is used.",
                   "It should be set to the lower case accented characters you",
                   "require in your locale.");
            if ( $forLowerNat ) {
                $n = NOTE("The following lower case accented characters have",
                          "been found in this locale and should be considered",
                          "for use in this parameter: <strong>$forLowerNat</strong>");
            }
            print ROW("LowerNational", $n);
        }
    }
}

# "Parse" TWiki.cfg
my $cfgfile = findFileOnPath("TWiki.cfg");
open(F, $cfgfile);
undef $/;
my $text = <F>;
close(F);
$text =~ s/^# //gm;

my $type;
my $descr;
my $opts;
foreach (split(/\r?\n/, $text)) {
    if( m/^\*\*([A-Z]+)(\s*.*?)\*\*/ ) {
        if( $type eq '_HELP' ) {
            print CGI::Tr(CGI::td({ colspan => 2 }, $descr));
        }
        $type = $1;
        $opts = $2 || '';
        $opts .= ' '; # to simplify parsing
        $descr = '';
    } elsif ($type && /\$(TWiki::)?cfg(.*?)\s*=/) {
        if( $type eq '_HELP' ) {
            print CGI::Tr(CGI::td({ colspan => 2 }, $descr));
        } else {
            print __checkAndBuildValueGrabber($type, $opts, $descr, $2);
        }
        $type = '';
        $descr = '';
    } elsif( m/^##+(.*?)#+$/ ) {
        print CGI::Tr(CGI::td({ colspan => 2 },CGI::h2( $1 )));
        $type = '_HELP';
    } elsif( $type ) {
        $descr .= "$_ ";
    }
}
print CGI::end_table(),
  CGI::submit(-onclick=>'verify_mandatory()', -value=>'Update'),
  CGI::end_form();

print '</div>';

print CGI::end_html();

# End of code

# Generates the appropriate HTML for getting a value to configure the
# entry. The opts are additional parameters, and by convention may
# be a number (for a string length), a comma separated list of values
# (for a select) and may also have an M for mandatory. The actual
# input field is decided by the type, which is used to compose a function
# name by prepending _prompt.
#.
# The method also builds a function name by prepending _check to the
# field name, and calls it if it exists to perform additional checking
# for that specific field (see _checkDataDir as an example)
#
sub __checkAndBuildValueGrabber {
    my( $type, $opts, $desc, $keys) = @_;

    my $mandatory = ($opts =~ /\sM\s/);
    # field id
    my $id = $keys;
    $id =~ s/}{/_/g;
    $id =~ s/[{}\[\]]//g;
    print CGI::hidden(-name => 'TYPEOF:'.$id, -value=>$type);
    my $value = eval '$TWiki::cfg'.$keys;
    my $prompter = '_prompt'.$type;
    no strict 'refs';
    $prompter = &$prompter($id, $opts, $value, $keys, $mandatory);
    my $class = $type;
    $class .= ' mandatory' if $mandatory;
    $prompter = CGI::span({class=>$class}, $prompter) if $mandatory;
    use strict 'refs';
    my $checker = '_check'.$id;
    if( defined &$checker ) {
        no strict 'refs';
        $desc .= &$checker($value, $keys);
        use strict 'refs';
    }

    my $docrow =
      CGI::Tr( CGI::td( { colspan => 2, class=>'docdata info' }, $desc ));

    $keys = CGI::span({class=>'mandatory'}, $keys) if $mandatory;
    my $keyrow =
      CGI::Tr( { class => 'keydata' },
               CGI::td( $keys ).CGI::td( $prompter ));

    return $docrow.$keyrow;
}

sub _promptSTRING {
    my( $id, $opts, $value, $keys ) = @_;
    my $size = 60;
    if( $opts =~ /\s(\d+)\s/ ) {
        $size = $1;
    }
    return CGI::textfield( -name => $id, -size=>$size, -default=>$value );
}

sub _promptURL {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptURLPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptPATH {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptBOOLEAN {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::checkbox( -name => $id, -checked => ( $value ? 1 : 0),
                          -value => 1, -label => '' );
}

sub _promptREGEX {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptCOMMAND {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>60, -default=>$value );
}

sub _promptNUMBER {
    my( $id, $opts, $value, $keys ) = @_;
    return CGI::textfield( -name => $id, -size=>20, -default=>$value );
}

sub _promptSELECT {
    my( $id, $opts, $value, $keys ) = @_;
    $opts =~ s/^\s+//;
    $opts =~ s/\s.*$//;
    $opts = '<option>'.
      join("</option><option>", split( /\s*,\s*/, $opts)).
        '</option>';
    return CGI::Select({ name => $id, size=>1, value=>$value }, $opts);
}

sub _checkDefaultUrlHost {
    my $val = $ENV{"HTTP_HOST"} || '';
    if( $TWiki::cfg{DefaultUrlHost} !~ /$val/ ) {
        return WARN('Current setting does not match HTTP_HOST (which is ',$val,')');
    }
}

sub _checkScriptUrlPath {
    # Check Script URL Path against REQUEST_URI
    my $n;
    my $val = $ENV{"REQUEST_URI"} || '';
    if( not $val ) {			# REQUEST_URI not set by IIS
        return WARN(<<HERE
This web server does not set <strong>REQUEST_URI</strong>,
so it isn't possible to check the correctness of this setting.
HERE
                  );
    } elsif ( $val !~ /^$TWiki::cfg{ScriptUrlPath}/ ) {
        return WARN('Current setting does not match <strong>REQUEST_URI</strong> ('.$val.')');
    }
}

sub _checkPubDir {
    return 'This is not set correctly if the link below is broken:<br />'.
      '<a href="'.$TWiki::cfg{PubUrlPath}.'">click here</a>'.
        checkdir( "PubDir", $TWiki::cfg{PubDir}, undef, "w" );
}

sub _checkTemplateDir {
    return checkdir( "TemplateDir", $TWiki::cfg{TemplateDir},
          "view.tmpl", "r" );
}

sub _checkDataDir {
    return checkdir( "DataDir", $TWiki::cfg{DataDir}, undef, "w" );

}

sub _checkMailProgram {
    eval "use Net::SMTP";
    my $n;
    if ($@) {
        $n = "Net::SMTP is <b>not</b> installed in this environment. ";
        my $val = $TWiki::cfg{MailProgram} || '';
        $val =~ s/\s.*$//g;
        if( ! ( -e $val ) ) {
            return WARN("<tt>$val</tt> was not found. Check the path.");
        }
    } else {
        $n = 'Net::SMTP is installed in this environment, so this setting will <b>not</b> be used.';
    }
    return $n;
}

sub _checkLogFileName {
    my $logFile = $TWiki::cfg{LogFileName} || "";
    my $logDir = $logFile;
    $logDir =~ s/\/[^\/]*$//;
    checkdir( "LogFileName", $logDir, undef, "w" );
}

sub _checkWarningFileName {
    my $logFile = $TWiki::cfg{WarningFileName} || "";
    my $logDir = $logFile;
    $logDir =~ s/\/[^\/]*$//;
    checkdir( "WarningFileName", $logDir, undef, "w" );
}

sub _checkDebugFileName {
    my $logFile = $TWiki::cfg{DebugFileName} || "";
    my $logDir = $logFile;
    $logDir =~ s/\/[^\/]*$//;
    checkdir( "DebugFileName", $logDir, undef, "w" );
}

sub testFileIsWritable {
    my( $name ) = @_;
    my $txt1 = "test 1 2 3";
    deleteTestFile( $name );
    writeTestFile( $name, $txt1 );
    my $txt2 = readTestFile( $name );
    deleteTestFile( $name );
    my $identical = ( $txt2 eq $txt1 );
    return $identical;
}

sub readTestFile {
    my( $name ) = @_;
    my $data = "";
    undef $/; # set to read to EOF
    open( IN_FILE, "<$name" ) || return "";
    $data = <IN_FILE>;
    $/ = "\n";
    close( IN_FILE );
    return $data;
}

sub writeTestFile {
    my( $name, $text ) = @_;
    if( open( FILE, ">$name" ) ) {
        print FILE $text;
        close( FILE);
    }
}

sub deleteTestFile {
    my( $name ) = @_;
    if( -e $name ) {
        unlink $name;
    }
}

# Since Windows (without Cygwin) makes it hard to capture stderr
# ('2>&1' works only on Win2000 or higher), and Windows will usually have
# GNU tools in any case (installed for TWiki since there's no built-in
# diff, grep, patch, etc), we only check for these tools on Unix/Linux 
# and Cygwin.  
sub checkGnuVersion {
    my $ok = 0;

    my ($progExecString, $progReadableName, $progUsage) = @_;        # Usage is 'used for...' string

    if( $TWiki::cfg{OS} eq 'UNIX' or  ($TWiki::cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
        $progExecString =~ s/\s.*$//;
        my $diffOut = `$progExecString --version 2>&1` || "";
        my $notFound = ( $? == -1 );
        my $n;
        if( $notFound ) {
            $n = WARN("'$progReadableName' program was not found on the",
                       "current PATH.");
        } elsif ( $diffOut !~ /\bGNU\b/ ) {
            # Program found on path, complain if no GNU in version output
            $n = WARN("'$progReadableName' program was found on the PATH",
                       "but is not GNU $progReadableName - this may cause",
                       "problems. $diffOut");
        } else {
            $n = "GNU $progReadableName was found on the PATH -".
                  " this is the recommended $progReadableName tool.";
	    $ok = 1;
        }

        ROW($progReadableName, $n, NOTE("The '$progReadableName' command is $progUsage."));
    }

    return $ok;
}

# check we can create a file
sub checkdir {
    my( $id, $dir, $file, $perms ) = @_;

    if (! defined $dir) {
      $file =~ /(.*)\/(.*?)/;
      $dir = $1;
      $file = $2;
    }
    my $n = $dir;
    if( defined $file && !-e "$dir/$file" ) {
        $n .= ERROR("Directory $dir does not exist or file <tt>$file</tt> does not exist in this directory.");
    } elsif( $perms =~ /w/ && ! testFileIsWritable( "$dir/testenv.test" ) ) {
        $n .= ERROR("The directory $dir must exist and be writable by the <strong>$usr</strong> user.");
    } elsif( $perms !~ /w/ && testFileIsWritable( "$dir/testenv.test" ) ) {
        $n .= WARN("Security issue: The directory $dir should not be writable by the <strong>$usr</strong> user.");
    }
    return $n;
}

sub _checkScriptSuffix {
    # SMELL: should check to see what the extension on _this_ script
    # is, and generate a helpful message
    return '';
}

sub _checkStoreImpl {
    my $bad = '';
    if( $TWiki::cfg{StoreImpl} eq 'RcsWrap') {
        foreach my $key( %{$TWiki::cfg{RCS}} ) {
            if ( $key && $key =~ /Cmd$/ ) {
                my $proggy = $TWiki::cfg{RCS}{$key} || "";
                $proggy =~ s/\s.*$//;
                if( $proggy) {
                    my $version = `$proggy -V` || '';
                    $version =~ /(\d+(\.\d+)+)/;
                    $version = $1;
                    $proggy .= " (version $version)";
                    $proggy .= " (Cygwin package <tt>rcs-$cygwinRcsVerNum</tt>)" if defined($cygwinRcsVerNum);
                    if( $proggy =~ /\/(rcs|rlog|rcsdiff|co)\b$/ &&
                        $version && $version < $rcsverRequired ) {
                        # RCS too old
                        $bad .= ERROR($proggy.' is too old, upgrade to version $rcsverRequired or higher.');
                    }
                }
            }
        }
    }

    if( $bad ) {
        $bad .= <<HERE;
TWiki will not work with this RCS setup. Either correct the setup, or
switch to RcsLite. To enable RCSLite you need to change the setting of
{StoreImpl} to 'RcsLite'.
HERE
        return $bad;
    }
    return '';
}

sub H3 {
    my $text = join("\n",@_);
    return CGI::Tr(CGI::th({align=>'left', valign=>'top', colspan=>'2'},
                           CGI::h3($text)));
}

sub H2 {
    my $text = join("\n",@_);
    return CGI::Tr(CGI::th({align=>'left', valign=>'top', colspan=>'2'},
                           CGI::h2($text)));
}

sub ROW {
    my $left = shift;
    my $right = join("\n", @_);
    return CGI::Tr(CGI::th({ class => 'keydata' },$left), CGI::td($right));
}

# a note
sub NOTE {
    return CGI::p({class=>"info"},CGI::strong('Note:').join("\n",@_));
}

# a warning
sub WARN {
    return CGI::p({class=>'warn'},CGI::strong('Warning:').join("\n",@_));
}

# an error
sub ERROR {
    return CGI::p({class=>'error'},CGI::strong('Error:').join("\n",@_));
}

sub findFileOnPath {
    my $file = shift;
    $file =~ s(::)(/)g;

    foreach my $dir ( @INC ) {
        if( -e "$dir/$file" ) {
            return "$dir/$file";
        }
    }
    return undef;
}

sub setConfig {
    my $updates = shift;
    my $lsc = findFileOnPath('LocalSite.cfg');
    unless( $lsc ) {
        $lsc = findFileOnPath('TWiki.cfg');
        die "Can't find key twiki components" unless $lsc;
        $lsc =~ s/TWiki\.cfg/LocalSite.cfg/;
    }
    open(F, "<$lsc") ||
      die "Failed to open $lsc for read";
    undef $/;
    my $txt = <F>;
    close(F);

    foreach my $config ( keys %$updates ) {
        # kill the old settings if any are there
        $txt =~ s/\$TWiki::cfg\{$config\}\s*=.*?;//s;
    }
# Currently disabled, as could screw over ntwiki
#    open(F, ">$lsc") ||
#      die "Failed to open $lsc for write";
#    print F $txt if $txt;
#    foreach my $config ( keys %$updates ) {
#        # kill the old settings if any are there
#        print F '$TWiki::cfg{',$config,'} = ',$updates->{$config},";\n";
#    }
#    close(F);
}

sub perlifyType {
    my ($val,$type) = @_;

    if ($type eq 'REGEX') {
        return "qr($val)";
    } elsif ($type eq 'BOOLEAN') {
        return ($val ? 1 : 0);
    } elsif ($type eq 'NUMBER') {
        return 0+$val;
    } else {
        $val =~ s/'/\\'/g;
        return "'$val'";
    }
}
1;
