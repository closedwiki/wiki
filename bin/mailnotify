#!/usr/bin/perl -wT
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# Copyright (C) 1999-2003 Peter Thoeny, peter@thoeny.com
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at 
# http://www.gnu.org/copyleft/gpl.html

# Colas (http://colas.nahaboo.net)
# modifications from mailnotify script from Dec 2001 release:
# - email is now optional, is fetched from the user homepage
# - webs not beginning by a capital letter are ignored ( _default, ...)
# - no mail is sent to TWikiGuest
# - if user is a group, recurses through its members

BEGIN {
    # Set library paths in @INC at compile time
    unshift @INC, '.';
    require 'setlib.cfg';
}

use TWiki;
use TWiki::Net;

my $debug = ! ( @ARGV && $ARGV[0] eq "-q" );

&main();

sub main
{
    &TWiki::basicInitialize();

    $debug && print "TWiki mail notification\n";
    $debug && print "- to suppress all normal output: mailnotify -q\n";

    my $dataDir = &TWiki::getDataDir();
    opendir( DIR, "$dataDir" ) or die "could not open $dataDir";
    @weblist = grep !/^\.\.?$/, readdir DIR;
    closedir DIR;
    foreach $web ( @weblist ) {
	# Only process webs with normal names, i.e. not starting with '_'
        if( -d "$dataDir/$web" && &TWiki::isWebName($web) ) {
             processWeb( $web );

             # remove obsolete .lock files
             $TWiki::T->{store}->removeObsoleteTopicLocks( $web );
        }
    }
    $debug && print "End TWiki mail notification\n";
}

sub processWeb
{
    my( $web) = @_;

    my ( $topic, $webName, undef, $userName, $dataDir) = 
	&TWiki::initialize( "/$web", "nobody" );

    $debug && print "Checking TWiki.$webName\n";

    if( ! $TWiki::T->{store}->webExists( $webName ) ) {
	print STDERR "* ERROR: TWiki mailnotify does not find web $webName\n";
	return;
    }

    my @notifylist = TWiki::getEmailNotifyList($webName);
    unless ( scalar @notifylist ) {
	$debug && print "<none>\n";
	return;
    }

    my $emailbody = "";
    my $topiclist = "";

    my $skin = TWiki::Prefs::getPreferencesValue( "SKIN" );
    my $text = TWiki::Store::readTemplate( "changes", $skin );
    my $changes= $TWiki::T->{store}->readFile( "$dataDir/$webName/.changes" );

    my %exclude;

    $text = &TWiki::handleCommonTags($text, $topic);
    $text =~ s/\%META{.*?}\%//go;  # remove %META{"parent"}%

    if( $TWiki::doRemoveImgInMailnotify ) {
        # change images to [alt] text if there, else remove image
        $text =~ s/<img src=.*?alt=\"([^\"]+)[^>]*>/[$1]/goi;
        $text =~ s/<img src=.*?[^>]>//goi;
    }

    my $before = "";
    my $after = "";
    ( $before, $text, $after) = split( /%REPEAT%/, $text );
    $emailbody = &TWiki::Render::getRenderedVersion( $before );
    $after = &TWiki::Render::getRenderedVersion( $after );

    my $prevLastmodify =
      $TWiki::T->{store}->readFile( "$dataDir/$webName/.mailnotify" ) || "0";
    my $currLastmodify = "";
    my $scriptSuffix = $TWiki::scriptSuffix;
    my $scriptUrlPath = $TWiki::scriptUrlPath;
    my $scriptUrl = $TWiki::T->{urlHost}.$scriptUrlPath;
    my $frev = "";

    foreach( reverse split( /\n/, $changes ) ) {
	# Parse lines from .changes:
	# <topic>	<user>		<change time>	<revision>
	# WebHome	FredBloggs	1014591347	21

	my ($topicName, $userName, $changeTime, $revision) = split( /\t/);
	$newText = $text;		# Repeating text from email template

	if( ( ! %exclude ) || ( ! $exclude{ $topicName } ) ) {
            next unless $TWiki::T->{store}->topicExists( $webName, $topicName );

	    if( ! $currLastmodify ) {
	        # newest entry
	        $time = &TWiki::formatTime( $prevLastmodify );
	        if( $prevLastmodify eq $changeTime ) {
	            # newest entry is same as at time of previous notification
	            $debug && print "- Note: No topics changed since $time\n";
	            return;
	        }
	        $currLastmodify = $changeTime;
	        $debug && print "- Changed topics since $time: ";
	    }

	    if( $prevLastmodify >= $changeTime ) {
	        #print "Date: found item of last notification\n";
	        # found item of last notification
	        last;
	    }
            $frev = "";
            if( $revision ) {
                if( $revision > 1 ) {
                    $frev = "r1.$revision";
                } else {
                    $frev = "<b>NEW</b>";
                }
            }

	    # Create entry in HTML attachment
	    $newText = $text;
	    $newText =~ s/%TOPICNAME%/$topicName/go;
	    $wikiuser = $TWiki::T->{users}->userToWikiName( $userName );

	    $newText =~ s/%AUTHOR%/$wikiuser/go;
            $newText =~ s/%LOCKED%//go;
	    $time = &TWiki::formatTime( $changeTime );
            $newText =~ s/%TIME%/$time/go;
            $newText =~ s/%REVISION%/$frev/go;
            $newText = $TWiki::T->{renderer}->getRenderedVersion( $newText );

            $head = $TWiki::T->{store}->readFile( "$dataDir\/$webName\/$topicName.txt", 16 );
            $head = TWiki::makeTopicSummary( $head, $topicName, $webName );
            $newText =~ s/%TEXTHEAD%/$head/go;

	    $emailbody .= $newText;
	    $exclude{ $topicName } = "1";

	    $debug && print "$topicName ";

	    # URL-encode topic names for use of I18N topic names in plain text
	    $webNameEnc = TWiki::handleUrlEncode( $webName );
	    my $topicNameEnc = TWiki::handleUrlEncode( $topicName );

	    # Create entry in plain-text email body
	    $newText = "- $topicName  ($wikiuser)\n  $scriptUrl/view$scriptSuffix/$webNameEnc/$topicNameEnc\n";
            $newText =~ s/Main\.//go;
	    $topiclist = "$topiclist$newText";
	}
    }

    if( $topiclist eq "" ) {
	$debug && print "- Note: Topic list is empty\n";
	return;
    }
    $debug && print "\n";

    $emailbody .= $after;

    my $from = &TWiki::Prefs::getPreferencesValue("WIKIWEBMASTER");

    my $notifylist = join ', ', @notifylist;

    $text = &TWiki::Store::readTemplate( "mailnotify", $skin );
    $text =~ s/%EMAILFROM%/$from/go;
    $text =~ s/%EMAILTO%/$notifylist/go;
    $text =~ s/%EMAILBODY%/$emailbody/go;
    $text =~ s/%TOPICLIST%/$topiclist/go;
    $text =~ s/%LASTDATE%/&TWiki::formatTime($prevLastmodify)/geo;
    $text = &TWiki::handleCommonTags( $text, $topic );

    # change absolute addresses to relative ones & do some cleanup
    $text =~ s/(href=\")$scriptUrlPath/$1..\/../goi;
    $text =~ s/(action=\")$scriptUrlPath/$1..\/../goi;
    $text =~ s/( ?) *<\/?(nop|noautolink)\/?>\n?/$1/gois;   # remove <nop> and <noautolink> tags

    $debug && print "- Sending mail notification to: $notifylist\n";

    my $error = $TWiki::T->{net}->sendEmail( $text );
    if( $error ) {
	print STDERR "* $error\n";
        $debug && print "- End TWiki.$webName\n";

    } else {
        &TWiki::Store::saveFile( "$dataDir/$webName/.mailnotify", $currLastmodify );

	$debug && print "- End TWiki.$webName, mail notification sent\n";
    }
}

=pod

---++ getEmailNotifyList( $webName, $topicName )
Return value: @emailNotifyList

Get email list from WebNotify page - this now handles entries of the form:
   * Main.UserName 
   * UserName 
   * Main.GroupName
   * GroupName
The 'UserName' format (i.e. no Main webname) is supported in any web, but
is not recommended since this may make future data conversions more
complicated, especially if used outside the Main web.  %<nop>MAINWEB% is OK
instead of 'Main'.  The user's email address(es) are fetched from their
user topic (home page) as long as they are listed in the '* Email:
fred@example.com' format.  Nested groups are supported.

=cut

sub getEmailNotifyList
{
    my( $web, $topicname ) = @_;

    $topicname = $notifyTopicname unless $topicname;
    return() unless $TWiki::T->{store}->topicExists( $web, $topicname );

    # Allow %MAINWEB% as well as 'Main' in front of users/groups -
    # non-capturing regex.
    my $mainWebPattern = qr/(?:$mainWebname|%MAINWEB%)/;

    my @list = ();
    my %seen;			# Incremented when email address is seen
    foreach ( split ( /\n/, TWiki::Store::readWebTopic( $web, $topicname ) ) ) {
        if ( /^\s+\*\s(?:$mainWebPattern\.)?($regex{wikiWordRegex})\s+\-\s+($regex{emailAddrRegex})/o ) {
	    # Got full form:   * Main.WikiName - email@domain
	    # (the 'Main.' part is optional, non-capturing)
	    if ( $1 ne 'TWikiGuest' ) {
		# Add email address to list if non-guest and non-duplicate
		push (@list, $2) unless $seen{$1}++;
            }
        } elsif ( /^\s+\*\s(?:$mainWebPattern\.)?($regex{wikiWordRegex})\s*$/o ) { 
	    # Got short form:   * Main.WikiName
	    # (the 'Main.' part is optional, non-capturing)
            my $userWikiName = $1;
            foreach ( getEmailOfUser($userWikiName) ) {
		# Add email address to list if it's not a duplicate
                push (@list, $_) unless $seen{$_}++;
            }
        }
    }
    ##writeDebug "list of emails: @list";
    return( @list);
}

=pod

---++ getEmailOfUser( $wikiName )
Return value: ( $userEmail ) or @groupEmailList

Get e-mail address for a given WikiName from the user's home page, or
list of e-mail addresses for a group.  Nested groups are supported.
$wikiName must contain _only_ the WikiName; do *not* pass names of the
form "Main.JohnSmith".

=cut

sub getEmailOfUser
{
    my( $wikiName ) = @_;		# WikiName without web prefix

    my @list = ();
    # Ignore guest entry and non-existent pages
    if ( $wikiName ne "TWikiGuest" && 
		$TWiki::T->{store}->topicExists( $mainWebname, $wikiName ) ) {
        if ( $wikiName =~ /Group$/ ) {
            # Page is for a group, get all users in group
	    ##writeDebug "using group: $mainWebname . $wikiName";
	    my @userList = TWiki::Access::getUsersOfGroup( $wikiName ); 
	    foreach my $user ( @userList ) {
		$user =~ s/^.*\.//;	# Get rid of 'Main.' part.
		foreach my $email ( getEmailOfUser($user) ) {
		    push @list, $email;
		}
	    }
        } else {
	    # Page is for a user
	    ##writeDebug "reading home page: $mainWebname . $wikiName";
            foreach ( split ( /\n/, &TWiki::Store::readWebTopic( 
					    $mainWebname, $wikiName ) ) ) {
                if (/^\s\*\sEmail:\s+([\w\-\.\+]+\@[\w\-\.\+]+)/) {   
		    # Add email address to list
                    push @list, $1;
                }
            }
        }
    }
    return (@list);
}

