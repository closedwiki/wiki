#!/usr/bin/perl -w
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# Copyright (C) 2000-2004 Peter Thoeny, peter@thoeny.com
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at
# http://www.gnu.org/copyleft/gpl.html
#
# DESCRIPTION: Test utility to see if CGI is running and enabled
# for the bin directory, and check a variety of TWiki, Perl and RCS
# setup.

# NOTE: Testenv should always run on older TWiki versions, as far as
# possible - so any dependency on TWiki modules should be carefully 
# handled and error checked.  If a newer feature or subroutine is not
# there, it's OK to fail silently and not do the associated tests.  This is
# more painful to code, but it means that testenv can be downloaded from
# SVN and used on older TWiki versions to diagnose problems.

package TWiki;

use vars qw( $setlibAvail );


my $brokenTWikiCfg;
my $brokenLocalSiteCfg;

BEGIN {
    # Set default current working directory
    if( $ENV{"SCRIPT_FILENAME"} && $ENV{"SCRIPT_FILENAME"} =~ /^(.+)\/[^\/]+$/ ) {
        chdir $1;
    }

    # Set library paths in @INC, read TWiki.cfg and set locale, at compile time
    # Try to use setlib.cfg, use default path if missing
    if ( -r './setlib.cfg' ) {
        require './setlib.cfg'; 
        $setlibAvail = 1;
    } else {
        unshift @INC, '../lib';
        $setlibAvail = 0;
    }
    if( $OS ) {
        $cfg{DetailedOS} = $detailedOS;
        $cfg{OS} = $OS;
    } else {
        # SMELL: duplicates code in TWiki.pm
        unless( ( $cfg{DetailedOS} = $^O ) ) {
            require Config;
            $cfg{DetailedOS} = $Config::Config{'osname'};
        }
        $cfg{OS} = 'UNIX';
        if ($cfg{DetailedOS} =~ /darwin/i) { # MacOS X
            $cfg{OS} = 'UNIX';
        } elsif ($cfg{DetailedOS} =~ /Win/i) {
            $cfg{OS} = 'WINDOWS';
        } elsif ($cfg{DetailedOS} =~ /vms/i) {
            $cfg{OS} = 'VMS';
        } elsif ($cfg{DetailedOS} =~ /bsdos/i) {
            $cfg{OS} = 'UNIX';
        } elsif ($cfg{DetailedOS} =~ /dos/i) {
            $cfg{OS} = 'DOS';
        } elsif ($cfg{DetailedOS} =~ /^MacOS$/i) { # MacOS 9 or earlier
            $cfg{OS} = 'MACINTOSH';
        } elsif ($cfg{DetailedOS} =~ /os2/i) {
            $cfg{OS} = 'OS2';
        }
    }

    # Read the configuration file now in order to set locale;
    # includes checking for broken syntax etc.  Need 'require'
    # to get the $!/$@ to work.
    $brokenLocalSiteCfg = 0;
    unless( eval 'require "LocalSite.cfg" ' ) {
        # Capture the Perl error(s)
        $brokenLocalSiteCfg = 1;	
        $brokenLocalSiteError = 
          ( $! ? "$!\n" : '') .	# $! if not readable,
			( $@ ? "$@\n" : '');	# $@ if not compileable
    }
    $brokenTWikiCfg = 0;
    unless( eval 'require "TWiki.cfg" ' ) {
        # Capture the Perl error(s)
        $brokenTWikiCfg = 1;	
        $brokenTWikiCfgError = 
          ( $! ? "$!\n" : '') .	# $! if not readable,
			( $@ ? "$@\n" : '');	# $@ if not compileable
    }

    # upgrade cfg from old twiki version
    $cfg{DefaultUrlHost} ||= $defaultUrlHost;
    $cfg{ScriptUrlPath} ||= $scriptUrlPath;
    $cfg{DispScriptUrlPath} ||= $dispScriptUrlPath;
    $cfg{PubUrlPath} ||= $pubUrlPath;
    $cfg{PubDir} ||= $pubDir;
    $cfg{TemplateDir} ||= $templateDir;
    $cfg{DataDir} ||= $dataDir;
    $cfg{ScriptSuffix} ||= $scriptSuffix;
    $cfg{UploadFilter} ||= $uploadFilter;
    $cfg{SafeEnvPath} ||= $safeEnvPath;
    $cfg{MailProgram} ||= $mailProgram;
    $cfg{NoSpamPadding} ||= $noSpamPadding;
    $cfg{MimeTypesFileName} ||= $mimeTypesFilename;
    $cfg{StoreImpl} ||= $storeTopicImpl;
    $cfg{RCS}{EgrepCmd} ||= $cfg{EgrepCmd} || $egrepCmd;
    $cfg{RCS}{FgrepCmd} ||= $cfg{FgrepCmd} || $fgrepCmd;
    $cfg{DisplayTimeValues} ||= $displayTimeValues;
    $cfg{UseLocale} ||= $useLocale;
    $cfg{SiteLocale} ||= $siteLocale;
    $cfg{SiteCharsetOverride} ||= $siteCharsetOverride;
    $cfg{LocaleRegexes} ||= $localeRegexes;
    $cfg{UpperNational} ||= $upperNational;
    $cfg{LowerNational} ||= $lowerNational;
    $cfg{NameFilter} ||= $securityFilter;
    $cfg{DefaultUserLogin} ||= $defaultUserName;
    $cfg{SiteWebTopicName} ||= $siteWebTopicName;
    $cfg{UsersWebName} ||= $mainWebname;
    $cfg{SystemWebName} ||= $twikiWebname;
    $cfg{DebugFileName} ||= $debugFilename;
    $cfg{WarningFileName} ||= $warningFilename;
    $cfg{HtpasswdFormatFamily} ||= $htpasswdFormatFamily;
    $cfg{AuthRealm} ||= $authRealm;
    $cfg{LogFileName} ||= $logFilename;
    $cfg{RemoteUserFileName} ||= $remoteUserFilename;
    $cfg{UsersTopicName} ||= $wikiUsersTopicname;
    $cfg{MapUserToWikiName} ||= $doMapUserToWikiName;
    $cfg{UsersTopicName} ||= $mainTopicname;
    $cfg{NotifyTopicName} ||= $notifyTopicname;
    $cfg{SitePrefsTopicName} ||= $wikiPrefsTopicname;
    $cfg{WebPrefsTopicName} ||= $webPrefsTopicname;
    $cfg{Stats}{TopicName} ||= $statisticsTopicname;
    $cfg{Stats}{TopViews} ||= $statsTopViews;
    $cfg{Stats}{TopContrib} ||= $statsTopContrib;
    $cfg{NumberOfRevisions} ||= $numberOfRevisions;
    $cfg{SuperAdminGroup} ||= $superAdminGroup;
    $cfg{GetScriptUrlFromCgi} ||= $doGetScriptUrlFromCgi;
    $cfg{RemovePortNumber} ||= $doRemovePortNumber;
    $cfg{RemoveImgInMailnotify} ||= $doRemoveImgInMailnotify;
    $cfg{RememberUserIPAddress} ||= $doRememberRemoteUser;
    $cfg{PluralToSingular} ||= $doPluralToSingular;
    $cfg{HidePasswdInRegistration} ||= $doHidePasswdInRegistration;
    $cfg{DenyDotDotInclude} ||= $doSecureInclude;
    $cfg{Log}{view} ||= $doLogTopicView;
    $cfg{Log}{edit} ||= $doLogTopicEdit;
    $cfg{Log}{save} ||= $doLogTopicSave;
    $cfg{Log}{rename} ||= $doLogRename;
    $cfg{Log}{attach} ||= $doLogTopicAttach;
    $cfg{Log}{upload} ||= $doLogTopicUpload;
    $cfg{Log}{rdiff} ||= $doLogTopicRdiff;
    $cfg{Log}{changes} ||= $doLogTopicChanges;
    $cfg{Log}{search} ||= $doLogTopicSearch;
    $cfg{Log}{register} ||= $doLogRegistration;
    $cfg{DisableAllPlugins} ||= $disableAllPlugins;
    my %ss = @storeSettings;
    $cfg{RCS}{useSubDir} ||= $useRcsDir;
    $cfg{RCS}{asciiFileSuffixes} ||= $ss{attachAsciiPath};
    $cfg{RCS}{dirPermission} ||= $ss{dirPermission};
    $cfg{RCS}{initBinaryCmd} ||= $ss{initBinaryCmd};
    $cfg{RCS}{tmpBinaryCmd} ||= $ss{tmpBinaryCmd};
    $cfg{RCS}{ciCmd} ||= $ss{ciCmd};
    $cfg{RCS}{coCmd} ||= $ss{coCmd};
    $cfg{RCS}{histCmd} ||= $ss{histCmd};
    $cfg{RCS}{infoCmd} ||= $ss{infoCmd};
    $cfg{RCS}{diffCmd} ||= $ss{diffCmd};
    $cfg{RCS}{ciDateCmd} ||= $ss{ciDateCmd};
    $cfg{RCS}{delRevCmd} ||= $ss{delRevCmd};
    $cfg{RCS}{unlockCmd} ||= $ss{unlockCmd};
    $cfg{RCS}{lockCmd} ||= $ss{lockCmd};

    # Do a dynamic 'use locale' for this script
    if( $cfg{UseLocale} ) {
        require locale;
        import locale ();
    }
}


# use strict;		# Recommended for mod_perl, enable for Perl 5.6.1 only
# Doesn't work well here, due to 'do "TWiki.cfg"'
# use diagnostics;	# Debug only

my $perlverRequired = 5.00503;		# Oldest supported version of Perl
my $perlverRequiredString = '5.005_03';
my $perlverRecommended = '5.6.1';
my $ActivePerlRecommendedBuild = 631;	# Fixes PERL5SHELL bugs

# CGI.pm version, on some platforms - actually need CGI 2.93 for mod_perl
# 2.0 and CGI 2.90 for Cygwin Perl 5.8.0.  See 
# http://perl.apache.org/products/apache-modules.html#Porting_CPAN_modules_to_mod_perl_2_0_Status
my $cgiModVerRecommended = '2.93';	

# Recommended mod_perl version if using mod_perl 2.0 (see Support.RegistryCookerBadFileDescriptor)
my $modPerlVersionRecommended = '1.99_12';	

my $rcsverRequired = 5.7;

# Required for testenv to work
my %basicMods =
  (
   'CGI'       => "basic TWiki",
   'CGI::Carp' => "basic TWiki"
  );

my %requiredMods =
  (
   'File::Copy' => 'basic TWiki',
   'File::Spec' => 'basic TWiki',
   'FileHandle' => 'basic TWiki',
  );

# Required on non-Unix platforms (mainly Windows)
my %requiredModsNonUnix =
  (
   'Digest::SHA1' => "register script",
   'MIME::Base64' => "register script",
   'Net::SMTP'    => "registration emails and mailnotify",
  );

# Optional modules on all platforms
my %optionalMods =
  (
   'MIME::Base64'     => "HTTP Authentication to proxies (CPAN)",
   'POSIX'            => "I18N (core module) and Security",
   'Digest::MD5'      => "MD5 encoded passwords",
   'Encode'           => "I18N conversions (core module in Perl 5.8)",
   'Unicode::MapUTF8' => "I18N conversions (CPAN)",
   'Unicode::Map'     => "I18N conversions (CPAN)",
   'Unicode::Map8'    => "I18N conversions (CPAN)",
   'Jcode'            => "I18N conversions (CPAN)",
  );

$| = 1;                  # no buffering - FIXME: mod_perl issue?

# Check whether basic CGI modules exist (some broken installations of
# Perl don't have this, even though they are standard modules), and warn user
my $modMissing = 0;
my $mod;
foreach $mod (keys %basicMods) {
    eval "use $mod";
    if ($@) {
        unless ($modMissing) {
            print "Content-type: text/html\n\n";
            print "<html><head><title>Perl Module(s) missing</title></head>\n";
            print "<body>\n";
            print "<h1>Perl Module(s) missing</h1>\n";
        }
        $modMissing = 1;
        print "<p><b><font color=\"red\">Warning:</font></b> ";
        print "Essential module <b>$mod</b> not installed - please check your Perl\n";
        print "installation, including the setting of <b>\@INC</b>, and re-install Perl if necessary.</p>\n";
    }
}

# If any critical modules missing, display @INC and give up 
if ($modMissing) {
    print "<p><b>\@INC setting:</b><br /><tt> ";
    print join "<br />\n", @INC;
    print "</tt></p>\n";
    print "</body>\n</html>\n";
    exit;
}

# Load CGI modules (run-time, after checking they are accessible)
require CGI;
require CGI::Carp;
import CGI::Carp qw( fatalsToBrowser );

my $query = new CGI;

print $query->header(),
  $query->start_html("Test TWiki environment"),
  $query->h1("Test the environment for TWiki"),
  "Please read the <a href='http://TWiki.org/cgi-bin/view/TWiki/TWikiInstallationGuide'>TWikiInstallationGuide</a> for more information on TWiki installation.
If your TWiki site is working, the front page should be <a href='view'>right here</a>.";

# TWiki.cfg was read earlier, in BEGIN block.
# Check for broken TWiki.cfg and report any Perl error(s)
if ($brokenTWikiCfg) {
    $brokenTWikiCfgError =~ s!\n!<br />\n!sg; 	# Format properly
    print $query->h3("Configuration error");
    print "<b><font color=\"red\">WARNING:</font></b> ";
    print "TWiki.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) relate to TWiki.cfg and should help locate the problem.<p />\n";
    print "$brokenTWikiCfgError\n";

    # EARLY EXIT
    print $query->end_html();
    exit;
}
if ($brokenLocalSiteCfg) {
    $brokenLocalSiteError =~ s!\n!<br />\n!sg; 	# Format properly
    print $query->h3("Configuration error");
    print "<b><font color=\"red\">WARNING:</font></b> ";
    print "LocalSite.cfg is unreadable or has a configuration problem that is causing a Perl error - the following message(s) relate to TWiki.cfg and should help locate the problem.<p />\n";
    print "$brokenLocalSiteError\n";

    # EARLY EXIT
    print $query->end_html();
    exit;
}

print $query->start_table();
BIGHEAD("Environment variables");
my $key;
for $key ( sort keys %ENV ) {
    LEFT($key); RIGHT($ENV{$key});
}

BIGHEAD("CGI Setup");
# Make %ENV safer for CGI (should reflect TWiki.pm)
my $originalPath = $ENV{'PATH'} || '';
if( $cfg{SafeEnvPath} ) {
    $ENV{'PATH'} = $cfg{SafeEnvPath};
}
delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

# Get Perl version - output looks neater with new variable
my $perlvernum = $];
my $perlver;
if (defined $^V) {
    $perlver = $^V;             # New in Perl 5.6.1, one byte per part
    $perlver = ord(substr($perlver,0)) . "." . ord(substr($perlver,1))
                                       . "." . ord(substr($perlver,2));
} else {
    $perlver = $perlvernum
}

 

# Load Config module - used here and elsewhere
require Config;

# Set $cfg{DetailedOS} if not using later versions of TWiki.cfg for BeijingRelease
# - this code enables the latest testenv to be used with Dec 2001 and 
# earlier releases.
if ( !defined $cfg{DetailedOS} ) {
    $cfg{DetailedOS} = $Config::Config{'osname'};
    # print "$cfg{DetailedOS}<br>";
}

# Detect Perl flavour on Windows, and Cygwin Perl/RCS package versions
use vars qw($perltype);

my $cygwinRcsVerNum;
$perlverMsg = $perlver;		# Default version message
if ($cfg{DetailedOS} eq 'cygwin') {
    $perltype = 'Cygwin';				# Cygwin Perl only
    my ($pkg, $pkgName);

    # Get Cygwin perl's package version number
    $pkgName = 'perl';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$perlverMsg = $perlver . $pkg
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$perlverMsg = $pkg;
    }
	
    # Get Cygwin RCS's package version number
    $pkgName = 'rcs';
    $pkg = `/bin/cygcheck -c $pkgName | /bin/grep $pkgName 2>/dev/null`; 
    if ($?) { 
        $pkg = " [Can't identify package - cygcheck or grep not installed]";
	$cygwinRcsVerNum = $pkg;	
    } else {
	$pkg = (split ' ', $pkg)[1];	# Package version
	$cygwinRcsVerNum = $pkg;	
    }
} elsif ($cfg{DetailedOS} =~ /win/i && $cfg{DetailedOS} !~ /darwin/i ) {
    # Windows Perl - try ActivePerl-only function: returns number if
    # successful, otherwise treated as a literal (bareword).
    my $isActivePerl= eval 'Win32::BuildNumber !~ /Win32/';
    if( $isActivePerl ) {
	$perltype = 'ActiveState';
        $perlverMsg = $perlver . ", build " . Win32::BuildNumber();
    } else {
	# Could be SiePerl or some other Win32 port of Perl
	$perltype = 'SiePerl or other Windows Perl';
    }
} else {
    $perltype = 'generic';
}

# Detect executable name suffix, e.g. .exe on Windows or '' on Unix
# Avoid testing for .exe suffixes on Cygwin, since the built-in
# grep and ls don't end in '.exe', even though Perl's '_exe' setting
# indicates they should.
my $exeSuffix='';
if ( $Config::Config{'_exe'} and ($cfg{OS} eq 'WINDOWS' and $perltype ne 'Cygwin') ) { 
    if ( ! $ENV{'INTERIX_ROOT'} ) { #this is set is we are using UnixServicesForWindows (or INTERIX funnily enough) and they don't use .exe either
        $exeSuffix = $Config::Config{'_exe'};
    }
}


my $thePathInfo = $query->path_info(); 
# my $theRemoteUser = $query->remote_user();
my $theTopic = $query->param( 'topic' );
my $theUrl = $query->url;

# Detect whether mod_perl was loaded into Apache
my $modPerlLoaded = ( exists $ENV{'SERVER_SOFTWARE'} && 
			  ( $ENV{'SERVER_SOFTWARE'} =~ /mod_perl/ ));

# Detect whether we are actually running under mod_perl
# - test for MOD_PERL alone, which is enough.
my $usingModPerl = ( exists $ENV{'MOD_PERL'} );

# Get the version of mod_perl if it's being used
my $modPerlVersion;
if ( $usingModPerl ) {
    $modPerlVersion = eval 'use mod_perl; return $mod_perl::VERSION';
}


my $n = ucfirst(lc($cfg{OS}));
$n .= " ($cfg{DetailedOS})" if ( $cfg{DetailedOS} ne '' );
# OS
LEFT("Operating system"); RIGHT($n);

# Perl version and type
$perlverMsg .= " ($perltype)" if $perltype ne 'generic';
LEFT("Perl version"); RIGHT($perlverMsg);

if ( $perlvernum < $perlverRequired ) {
    LEFT("");
    RIGHT(WARN("This version of Perl is too old for use with TWiki -",
            "upgrade to at least Perl $perlverRequiredString",
            "and preferably to Perl $perlverRecommended."));
}

# Perl @INC (lib path)
LEFT("\@INC library path"); RIGHT(join "<br />\n", @INC );

NOTE("This is the Perl library path, used to load TWiki modules, ",
     "third-party modules used by some plugins, and Perl built-in modules.");


# Turn off fatalsToBrowser while checking module loads, to avoid load errors in
# browser in some environments.  
$CGI::Carp::WRAP = $CGI::Carp::WRAP = 0;	# Avoid warnings...

# Add to list of required modules if non-Unix, or MacOS X (detected by
# Perl as 'Darwin') - $cfg{DetailedOS} is set in TWiki.cfg.
$cfg{DetailedOS} ||= $cfg{DetailedOS};

# Check that the TWiki.pm module can be found
LEFT("TWiki module in \@INC path");
$mod = 'TWiki';
eval "use $mod";
my $twikiFound = 0;
if ($@) {
    RIGHT(WARN("'$mod.pm' not found - check path to <code>twiki/lib</code>",
         "and edit <code>twiki/bin/LocalLib.cfg</code> if necessary"));
} else {
    $twikiFound = 1;
    my $mod_version = eval '$TWiki::wikiversion || $TWiki::VERSION';
    $mod_version ||= 'unknown';
    RIGHT("OK, $mod.pm found (Version: <b>$mod_version</b>)");
}

# Do locale settings if TWiki.pm was found
my $showLocales = 0;
if ($twikiFound) {
    if( eval 'TWiki::_setupLocale()' ){	# Not in older TWiki.pm versions
        # Ignore errors silently
        $showLocales = 1;
    }
}

if ( defined $cfg{DetailedOS} and ($cfg{DetailedOS} =~ /darwin/i or $cfg{OS} ne 'UNIX') ) {
    map { $requiredMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
} else {
    # these are optional on Unix
    map { $optionalMods{$_} = $requiredModsNonUnix{$_} }
      keys %requiredModsNonUnix;
}

# Check that each of the required Perl modules can be loaded, and
# print its version number.
BOTH("Required Perl modules");
$n = "";
foreach $mod (keys %requiredMods) {
    eval "use $mod";
    if ($@) {
        LOWLEFT($mod);
        RIGHT(ERROR("not installed. Required for ",
                    $requiredMods{$mod}));
    } else {
        my $mod_version;
        $mod_version = ${"${mod}::VERSION"};
        LOWLEFT($mod);
        $n = $mod_version;
        # Check for potential CGI.pm module upgrade 
        if( $mod eq 'CGI' and $mod_version < $cgiModVerRecommended ) {
            if ( $perltype eq 'Cygwin' and $perlver eq '5.8.0' ) {
                # Recommend CGI.pm upgrade if using Cygwin Perl 5.8.0 
                $n .= WARN( "CGI.pm version $cgiModVerRecommended or higher",
                            "is recommended to avoid problems with attachment",
                            "uploads on Cygwin Perl $perlver.");
            } elsif ( $usingModPerl and $modPerlVersion >= 1.99 ) {
                # Recommend CGI.pm upgrade if using mod_perl 2.0, which
                # is reported as version 1.99 and implies Apache 2.0
                $n .= WARN("CGI.pm version $cgiModVerRecommended or higher is",
                           "recommended to avoid problems with mod_perl version",
                           "$modPerlVersion on Apache 2.0 or higher.");
            }
        }
        RIGHT($n);
    }
}

# Check that each of the optional Perl modules can be loaded, and
# print its version number.
BOTH("Optional Perl modules");
$n = "";
foreach $mod (keys %optionalMods) {
    eval "use $mod";
    LOWLEFT($mod);
    if ($@) {
        RIGHT(WARN("not installed. May be required for",
                   $optionalMods{$mod}));
    } else {
        my $mod_version = $ {"$ {mod}::VERSION"};
        RIGHT($mod_version);
    }
}

# All module checks done, OK to enable fatalsToBrowser
import CGI::Carp qw( fatalsToBrowser );

# PATH_INFO 
LEFT("PATH_INFO<a name=\"PATH_INFO\">");
RIGHT("$thePathInfo",
      NOTE("For a URL such as <b>$theUrl/foo/bar</b>,",
           "the correct PATH_INFO is <b>/foo/bar</b>, without any prefixed path",
           "components. <a href=\"$theUrl/foo/bar#PATH_INFO\">",
           "<b>Test this now</b></a>",
           "- particularly if you are using mod_perl, Apache or IIS, or are using",
           "a web hosting provider.",
           "The page resulting from the test link should have a PATH_INFO of",
           "<b>/foo/bar</b>."));

# mod_perl 
my $usingModPerlText = $usingModPerl ? "Used" : "Not used";
my $modPerlLoadedText = ( $modPerlLoaded ? "loaded" : "not loaded" );

$n = "$usingModPerlText for this script (mod_perl $modPerlLoadedText into Apache)\n";
if ( $modPerlVersion ) {
    $n .= "- mod_perl version $modPerlVersion\n";
}
LEFT("mod_perl");RIGHT($n);

# Check for a broken version of mod_perl 2.0
if ( $usingModPerl and $modPerlVersion >= 1.99 
        and $modPerlVersion eq '1.99_11' ) {
    # Recommend mod_perl upgrade if using a mod_perl 2.0 version
    # with PATH_INFO bug (see Support.RegistryCookerBadFileDescriptor)
    LEFT("");
    RIGHT(WARN("mod_perl version $modPerlVersionRecommended or higher",
               "is strongly recommended to avoid 'internal system error'",
               "bugs with PATH_INFO when using mod_perl $modPerlVersion",
               "and Apache 2.0 or higher."));
}


# Get web server's user and group info
my $usr = "";
my $grp = "";
if( $cfg{OS} eq 'UNIX' or  ($cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
    $usr = lc( getpwuid($>) );		# Unix/Cygwin Perl - effective UID
    foreach( split( " ", $( ) ) {
	my $onegrp = getgrgid( $_ );
	$grp .= " " . lc($onegrp);
    }
} else {				# ActiveState or other Win32 Perl
    $usr = lc( getlogin );
    # Try to use Cygwin's 'id' command - may be on the path, since Cygwin
    # is probably installed to supply ls, egrep, etc - if it isn't, give up.
    # Run command without stderr output, to avoid CGI giving error.
    # Get names of primary and other groups.
    $grp = lc(qx(sh -c '( id -un ; id -gn) 2>/dev/null' 2>nul ));
    if ($?) { 
        $grp = "[Can't identify groups - no Cygwin 'id' or 'sh' command on path]";
    }
}

LEFT("User");
$n = $usr.
  NOTE("Your CGI scripts are executing as this user.");
if( $usr ne "nobody" ) {
    $n .= WARN("Since your CGI script is not running as user",
               "<tt>nobody</tt>, you may need to change the locks",
               "in the *,v RCS files of the TWiki distribution from",
               "<tt>nobody</tt> to <tt>$usr</tt>. Otherwise, changes",
               "to topics will not be logged.");
}
RIGHT($n);

LEFT("Group(s)"); RIGHT($grp);

BIGHEAD("Configuration");;
LEFT("DefaultUrlHost");
$n = $cfg{DefaultUrlHost}.
  NOTE("This must match the protocol and host part (with optional",
       "port number) of the TWiki URL.");
my $val = $ENV{"HTTP_HOST"} || '';
if( $cfg{DefaultUrlHost} !~ /$val/ ) {
    $n .= WARN("This does not match </b>HTTP_HOST</b>");
}
RIGHT($n);

# Check Script URL Path against REQUEST_URI
LEFT("ScriptUrlPath"); 
$n = $cfg{ScriptUrlPath}.
  NOTE("This must match the 'cgi-bin' part of the URL used to access the",
       "TWiki cgi-bin directory.");
$val = $ENV{"REQUEST_URI"} || '';
if( not $val ) {			# REQUEST_URI not set by IIS
    $n .= WARN("This web server does not set <b>REQUEST_URI</b>,",
               "so it's not possible to check the correctness of ",
               "this setting.");
} elsif ( $val !~ /^$cfg{ScriptUrlPath}/ ) {
    $n .= WARN("This does not match <b>REQUEST_URI</b>");
}
RIGHT($n);

LEFT("PubUrlPath");
RIGHT($cfg{PubUrlPath},
  NOTE("This must be the URL of the public directory.",
       "This is not set correctly if the ",
       "$cfg{PubUrlPath}/wikiHome.gif image below is broken:<br />",
       "<img src=\"$cfg{PubUrlPath}/wikiHome.gif\" />"));

checkdir( "PubDir", $cfg{PubDir},
          NOTE("This is the public directory, as seen from the file system. ".
          "It must correspond to <b>PubUrlPath</b>."),
          "wikiHome.gif", "w" );

checkdir( "TemplateDir", $cfg{TemplateDir},
          NOTE("This is the template directory, as seen from the file system. "),
          "view.tmpl", "r" );

checkdir( "DataDir", $cfg{DataDir},
          NOTE("This is the data directory where TWiki stores all topics."),
          undef, "w" );

my $logFile = $cfg{LogFileName} || "";
my $logDir = $logFile;
$logDir =~ s/\/.*?$//;
checkdir( "LogFileName", $logDir, $logFile, undef, "w" );

$logFile = $cfg{WarningFileName} || "";
$logDir = $logFile;
$logDir =~ s/\/.*?$//;
checkdir( "WarningFileName", $logDir, $logFile, undef, "w" );

$logFile = $cfg{DebugFileName} || "";
$logDir = $logFile;
$logDir =~ s/\/.*?$//;
checkdir( "DebugFileName", $logDir, $logFile, undef, "w" );

LEFT("MailProgram");
$n = $cfg{MailProgram};
$val = $cfg{MailProgram} || '';
$val =~ s/\s.*$//g;
if( $cfg{OS} ne 'WINDOWS' && ! ( -e $val ) ) {
    $n .= WARN("Mail program <tt>$val</tt> not found. Check the path.");
} elsif( $cfg{OS} ne 'WINDOWS' ) {
    $n .= NOTE("This is the mail program TWiki uses to send mail,",
               "unless Net::SMTP is installed and %SMTPMAILHOST%",
              "is set in TWikiPreferences");
} else {
    $n .= NOTE("This is not typically used on Windows - the",
               "Perl Net::SMTP module is used instead.");
}
RIGHT($n);

# Check 'egrep'
LEFT("EgrepCmd");
$n = $cfg{RCS}{EgrepCmd}.
  NOTE("This is a program TWiki uses for searching." );
$val = $cfg{RCS}{EgrepCmd} . $exeSuffix;
$val =~ s/([^\s]*).*/$1/go;
if( ! ( -e $val ) ) {
    $n .= WARN("Search program <tt>$val</tt> not found. Check the path.");
}
RIGHT($n);

LEFT("FgrepCmd");
$n = $cfg{RCS}{FgrepCmd}.
  NOTE("This is a program TWiki uses for searching.");
$cfg{RCS}{FgrepCmd} =~ s/ .*//;   # Strip any options
$val = $cfg{RCS}{FgrepCmd} . $exeSuffix;
$val =~ s/([^\s]*).*/$1/go;
if( ! ( -e $val ) ) {
    $n = WARN("Search program <tt>$val</tt> not found. Check the path.");
}
RIGHT($n);

LEFT("SafeEnvPath");
$n = "This is used to initialise the PATH variable, and is used to run the".
  " 'diff' program used by RCS, as well as to run shell programs such as ";
if( $cfg{OS} eq 'WINDOWS' ) {
    $n .= " cmd.exe or Cygwin's 'bash'.<p>";
    if( $perltype eq 'Cygwin' ) {
        $n .= "Since you are using Cygwin Perl, 'bash' will be used without any special setup.";
    } elsif( $perltype eq 'ActiveState' ) {
        $n .= "To use 'bash' with ActiveState Perl, see the PERL5SHELL section below\n";
        $n .= "- this is recommended if Cygwin is installed.\n";
    }
    $n .= "</p>";
} else {
    $n .= "Bourne shell or 'bash'.";
}
if( !$cfg{SafeEnvPath} ) {
    $n .= WARN("Security issue: <b>SafeEnvPath</b> set to empty string.");
}
RIGHT($cfg{SafeEnvPath}, NOTE($n));

BIGHEAD("Revision control tools");
LEFT("StoreImpl");
RIGHT($cfg{StoreImpl});
if( $cfg{StoreImpl} eq "RcsWrap") {
    BOTH("The following programs are used by the RCS module");
    # Check RCS directory
    foreach my $key( %{$cfg{RCS}} ) {
        if ( $key && $key =~ /Cmd$/ ) {
            my $proggy = $cfg{RCS}{$key} || "";
            $proggy =~ s/\s.*$//;
            LOWLEFT($key);
            if( $proggy) {
                my $rcsVerNum = `$proggy -V`;
                $rcsVerNum = (split(/\s+/, $rcsVerNum))[2] || "";	# Recover from unset variable
                $proggy .= " (version $rcsVerNum)";
                $proggy .= " (Cygwin package <tt>rcs-$cygwinRcsVerNum</tt>)" if defined($cygwinRcsVerNum);
                if( $rcsVerNum && $rcsVerNum < $rcsverRequired ) {
                    # RCS too old
                    $proggy .= ERROR("The version of this program is too old, upgrade to version $rcsverRequired or higher.");
                    $badRCS = 1;
                }
            }
            RIGHT($proggy);
        }
    }

    if( $badRCS ) {
        BOTH(ERROR("TWiki will not work with this RCS setup.",
                   "Either correct the setup, or switch to RcsLite. ",
                   "To enable RCSLite you need to change the setting",
                   "of StoreImpl to 'RcsLite'."));
    }
}



# Generate a separate table about specific environment variables
BIGHEAD("Path and Shell Environment");

# Check PATH

LEFT("Original PATH");
RIGHT($originalPath,
      NOTE("This is the PATH value passed in from the web server to this",
           "script - it is reset by TWiki scripts to the PATH below, and",
           "is provided here for comparison purposes only."));

my $currentPath = $ENV{'PATH'} || ''; 	# As re-set earlier in this routine
LEFT("Current PATH");
RIGHT($currentPath,
NOTE("This is the actual PATH setting that will be used by Perl to run ",
     "programs. It is normally identical to <b>SafeEnvPath</b>, unless",
     "that variable is empty."));


# Check that GNU egrep is found in PATH
my $egrepOk = checkGnuVersion( $cfg{RCS}{EgrepCmd}, "egrep", "used for regular expression searches" );

# Check that GNU fgrep is found in PATH
my $fgrepOk = checkGnuVersion( $cfg{RCS}{FgrepCmd}, "fgrep", "used for non-regular expression searches" );

unless ( $egrepOk && $fgrepOk )
{
    LEFT();
    RIGHT( NOTE( qq{<a href="http://www.gnu.org/software/grep/grep.html" >grep</a> can be downloaded from <a href="http://www.gnu.org/">GNU</a>'s <a href="ftp://ftp.gnu.org/pub/gnu/grep/" >FTP</a> site} ) );
}

# Check that GNU diff is found in PATH
checkGnuVersion( "diff", "diff", "used by RCS to compare files" );

# Check that GNU patch is found in PATH 
checkGnuVersion( "patch", "patch", "used by the UpgradeTwiki script to upgrade an existing TWiki installation" );

# PERL5SHELL check for non-Cygwin Perl on Windows only
if( $cfg{OS} eq 'WINDOWS' && $perltype ne 'Cygwin' ) {

    # ActiveState or SiePerl/other
    # FIXME: Advice in this section should be reviewed and tested by people
    # using ActivePerl
    my $perl5shell = $ENV{'PERL5SHELL'} || '';
    LEFT("PERL5SHELL");
    $n = $perl5shell.
    NOTE("This environment variable is used by ActiveState and other",
         "Win32 Perls to run \n",
         "commands from TWiki scripts - it determines which shell\n",
         "program is used to run commands that use 'pipes'.  Examples",
         "of shell programs are \n",
         "cmd.exe, command.com (aka 'DOS Prompt'), and Cygwin's 'bash'\n",
         "(<b>recommended</b> if Cygwin is installed).\n",
         "<p>\n",
         "To use 'bash' with ActiveState or other Win32 Perls,",
         "you should set the \n",
         "PERL5SHELL environment variable to something like ",
         "<tt><b>c:/YOURCYGWINDIR/bin/bash.exe -c</b></tt>.",
         "This should be set in the System Environment, and ideally set \n",
         "directly in the web server (e.g. using the Apache <tt>SetEnv</tt>",
         "command, followed by an Apache restart). Once this is done, you",
         "should re-run <b>testenv</b>\n",
         "to check that PERL5SHELL is set properly.\n");
    if ($perltype eq 'ActiveState' and 
	    Win32::BuildNumber() < $ActivePerlRecommendedBuild ) {
    	$n .= WARN("ActiveState Perl must be upgraded to build <b>",
             $ActivePerlRecommendedBuild,
             "</b> if you are going to use PERL5SHELL, which was broken",
             "in earlier builds.");
    }
    RIGHT($n);
}

# User authentication and password handling (only if TWiki::User loaded)
if( defined $TWiki::htpasswdFormatFamily ) {
    BIGHEAD("User Authentication");

    $TWiki::htpasswdFormatFamily = $TWiki::htpasswdFormatFamily;	# warning fodder
    $TWiki::htpasswdEncoding = $TWiki::htpasswdEncoding;
    print "</td></tr>\n";
    LEFT("htpasswd Format Family"); RIGHT($TWiki::htpasswdFormatFamily);
    LEFT("htpasswd Encoding"); RIGHT($TWiki::htpasswdEncoding);
    LEFT("htpasswd Filename"); RIGHT($TWiki::htpasswdFilename);
    BOTH(NOTE("Only some combinations of Format, Encoding and Filename are",
         " valid, and fewer are tested"));
}

# Generate a separate table for locale setup
if ( $showLocales ) {		# Only if TWiki.pm found
    BIGHEAD("Internationalisation and Locale Setup");

    # $cfg{UseLocale}
    LEFT("UseLocale");
    $n = $cfg{UseLocale}.
     NOTE("This setting controls whether locales are used by Perl and 'grep'");

    if( $cfg{OS} eq 'WINDOWS' ) {
        # Warn re known broken locale setup
        $n .= WARN("Using Perl on Windows, which may have missing or",
                   "incorrect locales (in Cygwin or ActiveState Perl,",
                   "respectively) - use of <b>LocaleRegexes</b> = 0",
                   "(see below) is recommended unless you know your",
                   "version of Perl has working locale support.");
    }

    # Check for d_setlocale in Config (same as 'perl -V:d_setlocale')
    eval "use Config"; 
    if ( not ( exists $Config{d_setlocale} and $Config{d_setlocale} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled with locale",
                   "support ('d_setlocale' not set in Config.pm)",
                   "- re-compilation of Perl will be required before",
                   "it can be used to support TWiki internationalisation.");
    }
    RIGHT($n);

    LEFT("SiteLocale");
    $n = $cfg{SiteLocale}.
    NOTE("This sets the site-wide locale - for example,",
         "<b>de_AT.ISO-8859-1</b> where 'de' is the language code,",
         "'AT' the country code and 'ISO-8859-1' is the character set.",
         "Use the <code>locale -a</code> command on your system to",
         "determine available locales.");

    # Try to see if required locale was correctly set earlier
    my $currentLocale = setlocale(&LC_CTYPE);
    if ( $currentLocale ne $cfg{SiteLocale} ) {
        $n .= WARN("Unable to set locale to '$cfg{SiteLocale}'. The",
                   "actual locale is '$currentLocale'",
                   "- please test your locale settings. This warning can",
                   "be ignored if you are not planning to use locales (e.g.",
                   "your site uses English only) - or you can set ",
                   "<b>SiteLocale</b> to <code>C</code>, which should",
                   "always work.");
    }
    RIGHT($n);

    # $siteCharset (computed in TWiki::setupLocale from TWiki.cfg settings)
    if (not defined $cfg{SiteCharsetOverride} ) {
        $cfg{SiteCharsetOverride} = '';
    }

    LEFT("SiteCharsetOverride");
    $n = $cfg{SiteCharsetOverride}.
      NOTE("This only needs to be set if the calculated charset",
           "<b>$siteCharset</b>, which is derived from the site-wide",
           "locale setting, is wrong. This setting is used in HTML pages",
           "and HTTP headers, so it must be acceptable to web browsers",
           "even if it is different to the locale-derived setting",
           "(e.g. 'euc-jp' instead of 'eucjp')");

    # Warn against UTF-8 for now
    if ( $siteCharset eq 'utf-8' ) {
        $n .= WARN("UTF-8 is not fully supported as the TWiki site",
                   "character set at present",
                   "- while many features will work, it is recommended",
                   "to use a non-UTF-8 character set until full support",
                   "is completed.\n",
                   "If you are interested in testing TWiki beta releases",
                   "with improved UTF-8 support and have access to Perl ",
                   "5.8, see TWiki.org's ",
                   "<a href=\"http://twiki.org/cgi-bin/view/Codev/TWikiBetaRelease\">TWikiBetaRelease</a> topic.");
    }

	# Warn against Perl 5.6 or lower for UTF-8
	if ( $perlvernum < 5.008 ) {
        $n .= WARN("Perl 5.8 is required if you are using TWiki's",
                   "experimental UTF-8 support\n");
    }

    # Check for 'useperlio' in Config on Perl 5.8 or higher - required
    # for use of ':utf8' layer.
    if ( $perlvernum >= 5.008 and 
         not ( exists $Config{useperlio} and
               $Config{useperlio} eq 'define' ) ) {
        $n .= WARN("This version of Perl was not compiled to use PerlIO",
                   "by default ('useperlio' not set in Config.pm, see",
                   "<i>Perl's Unicode Model</i> in 'perldoc perluniintro')",
                   "- re-compilation of Perl will be required before it",
                   "can be used to enable TWiki's experimental UTF-8",
                   "support.");
    }
    RIGHT($n);

    LEFT("LocaleRegexes");
    $n = $cfg{LocaleRegexes}.
    NOTE("This setting (default: 1) controls whether\n",
         "locale-dependent regular expressions (e.g. <code>[:upper:]</code>) are\n",
         "used by Perl and 'grep'. It is used in environments where locales are\n",
         "broken, to allow use of internationalised WikiWords.  You should\n",
         "configure <b>UseLocale</b> to 1, and set a reasonable\n",
         "<b>SiteLocale</b>, since this enables correct setting of the\n",
         "site charset for use by web browsers. Don't change this\n",
         "setting unless your locales are not working for whatever reason\n");
    RIGHT($n);

    # Locales are off/broken, or using pre-5.6 Perl, so have to 
    # explicitly list the accented characters (but not if using UTF-8)
    my $perlVerPreferred = 5.006;	# 5.6 or higher has [:lower:] etc
    if ( ( not $cfg{UseLocale} or $perlvernum < $perlVerPreferred 
           or not $cfg{LocaleRegexes} )
         and $siteCharset ne 'utf-8' ) {

        # Can't use locales, so generate upper and lower case character
        # classes to avoid doing this at run-time in TWiki.
        my $forUpperNat;
        my $forLowerNat;
        if ( $perlvernum < $perlVerPreferred ) {
            # Get strings with the non-ASCII alphabetic characters only, upper and lower case
            $forUpperNat = join '', grep { lc($_) ne $_ and m/[^A-Z]/ } map { chr($_) } 1..255;
            $forLowerNat = join '', grep { uc($_) ne $_ and m/[^a-z]/ } map { chr($_) } 1..255;
        }

        unless( $cfg{UseLocale} && $cfg{LocaleRegexes} ) {
            LEFT("UpperNational");
            $n = $cfg{UpperNational}.
              NOTE("This setting is used when <b>UseLocale</b> is 0 or",
                   "<b>LocaleRegexes</b> is 0, to work around missing or",
                   "non-working locales.\n",
                   "It is also used with Perl 5.005 for efficiency reasons",
                   "- upgrading to Perl 5.6.1 with working locales is",
                   "recommended, and removes the need for this. \n",
                   "If required, it should be set to the upper case accented",
                   "characters you require in your locale.");
            if ( $forUpperNat ) {
                $n .= NOTE("The following upper case accented characters have",
                           "been found in this locale and should be considered",
                           "for use in this parameter: <b>$forUpperNat</b>");
            }
            RIGHT($n);
            LEFT("LowerNational");
            $n = $cfg{LowerNational}.
              NOTE("This setting is used whenever <b>UpperNational</b> is used.",
                   "It should be set to the lower case accented characters you",
                   "require in your locale.");
            if ( $forLowerNat ) {
                $n = NOTE("The following lower case accented characters have",
                          "been found in this locale and should be considered",
                          "for use in this parameter: <b>$forLowerNat</b>");
            }
            RIGHT($n);
        }
    }
}

print $query->end_table();

print $query->hr(),
  $query->h1("Complete list of configuration parameters"),
  explode(\%cfg);

print $query->end_html();

# End of code

sub testFileIsWritable
{
    my( $name ) = @_;
    my $txt1 = "test 1 2 3";
    deleteTestFile( $name );
    writeTestFile( $name, $txt1 );
    my $txt2 = readTestFile( $name );
    deleteTestFile( $name );
    my $identical = ( $txt2 eq $txt1 );
    return $identical;
}

sub readTestFile
{
    my( $name ) = @_;
    my $data = "";
    undef $/; # set to read to EOF
    open( IN_FILE, "<$name" ) || return "";
    $data = <IN_FILE>;
    $/ = "\n";
    close( IN_FILE );
    return $data;
}

sub writeTestFile
{
    my( $name, $text ) = @_;
    if( open( FILE, ">$name" ) ) {
        print FILE $text;
        close( FILE);
    }
}

sub deleteTestFile
{
    my( $name ) = @_;
    if( -e $name ) {
        unlink $name;
    }
}

# Since Windows (without Cygwin) makes it hard to capture stderr
# ('2>&1' works only on Win2000 or higher), and Windows will usually have
# GNU tools in any case (installed for TWiki since there's no built-in
# diff, grep, patch, etc), we only check for these tools on Unix/Linux 
# and Cygwin.  
sub checkGnuVersion {
    my $ok = 0;

    my ($progExecString, $progReadableName, $progUsage) = @_;        # Usage is 'used for...' string

    if( $cfg{OS} eq 'UNIX' or  ($cfg{OS} eq 'WINDOWS' and $perltype eq 'Cygwin' ) ) {		
        LEFT("$progReadableName");

        my $diffOut = `$progExecString --version 2>&1` || "";
        my $notFound = ( $? == -1 );
        my $n;
        if( $notFound ) {
            $n = WARN("'$progReadableName' program was not found on the",
                       "current PATH.");
        } elsif ( $diffOut !~ /\bGNU\b/ ) {
            # Program found on path, complain if no GNU in version output
            $n = WARN("'$progReadableName' program was found on the PATH",
                       "but is not GNU $progReadableName - this may cause",
                       "problems.");
        } else {
            $n = "GNU $progReadableName was found on the PATH -".
                  "this is the recommended $progReadableName tool.";
	    $ok = 1;
        }

        RIGHT($n, NOTE("The '$progReadableName' command is $progUsage."));
    }

    return $ok;
}

# check we can create a file
sub checkdir {
    my( $id, $dir, $descr, $file, $perms ) = @_;
    LEFT($id);

    if (! defined $dir) {
      $file =~ /(.*)\/(.*?)/;
      $dir = $1;
      $file = $2;
    }
    
    my $n = $dir;
    if( $descr ) {
        $n .= $descr;
    }
    if( defined $file && !-e "$dir/$file" ) {
        $n .= ERROR("Directory $dir does not exist or file <tt>$file</tt> does not exist in this directory.");
    } elsif( $perms =~ /w/ && ! testFileIsWritable( "$dir/testenv.test" ) ) {
        $n .= ERROR("The directory must exist and be writable by the <b>$usr</b> user.");
    } elsif( $perms !~ /w/ && testFileIsWritable( "$dir/testenv.test" ) ) {
        $n .= WARN("Security issue: The directory should not be writable by the <b>$usr</b> user.");
    }
    RIGHT($n);
}

# left column, highlit
sub LEFT {
    my $text = join(" ",@_);
    print "<tr valign='top'><th align='right'>$text";
    print ":" if $text;
    print "</th>\n";
}

# left column, not highlit
sub LOWLEFT {
    my $text = join(" ",@_);
    print "<tr valign='top'><td align='right'>$text";
    print ":" if $text;
    print "</td>\n";
}

# right column
sub RIGHT {
    my $text = join(" ",@_);
    $text =~ s/^<br \/>//;
    print "<td>$text</td></tr>\n";
}

# one column
sub BOTH {
    my $text = join(" ",@_);
    print "<th align='left' valign='top' colspan='2'>$text</th></tr>\n";
}

# both columns used to show a heading
sub BIGHEAD {
    print BOTH("<hr><h3>",join(" ",@_),"</h3>");
}

# a note
sub NOTE {
    return "<br /><font color='green'><b> Note: </font></b> ".join(" ",@_);
}

# a warning
sub WARN {
    return "<br /><font color='orange'><b> Warning:</b></font> ".join(" ",@_);
}

# an error
sub ERROR {
    return "<br /><font color='red'><b> Error: </b></font> ".join(" ",@_);
}

# expand a hash into a human-readable table. used to show all
# cfg vars
sub explode {
    my $hash = shift;
    my $tab = "";
    foreach $n ( sort keys %$hash ) {
        $tab .= "<tr valign='top'><th align='left'>$n</th>\n";
        if( ref($hash->{$n}) =~ /^HASH/) {
            $tab .= "<td valign='top'>{".explode($hash->{$n})."}</td>\n";
        } else {
            my $val = $hash->{$n} || "";
            $tab .= "<td><tt>$val</tt></td>\n";
        }
        $tab .= "</tr>";
    }
    return "<table>\n$tab</table>";
}
