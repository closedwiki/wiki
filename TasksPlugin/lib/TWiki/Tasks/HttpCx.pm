# -*- mode: CPerl; -*-
# TWiki off-line task management framework addon for the TWiki Enterprise Collaboration Platform, http://TWiki.org/
#
# Copyright (C) 2011 Timothe Litt <litt at acm dot org>
# License is at end of module.
# Removal of Copyright and/or License prohibited.


use strict;
use warnings;

=pod

---+ package TWiki::Tasks::HttpCx
Select-threaded Http connection object.

This subclass of the GenericCx object specializes it for the HTTP protocol.

See GenericCx for documentation of the methods inherited from it.

Input and output parsing of HTTP headers is provided, as is parameter retrieval.

Although the resulting environment should be familiar to anyone who has written CGI scripts for a traditional webserver, this
implementation is a simplified subset intended to provide the minimal facilities necessary for managing the TASK daemon.  HTTP
was chosen for its availability on a wide range of client platforms.

For simplicity and robustness, this implementation does not support pipelining or keep-alive; simple one request/response per
connection.

=cut


package TWiki::Tasks::HttpCx;

use base qw/TWiki::Tasks::GenericCx/;


use HTTP::Date qw //;
use HTTP::Status qw/:constants/;
use Socket qw/:crlf AF_INET/;

=pod

---++ ClassMethod new( $server, $socket ) -> $cx
Constructor for a new HttpCx object
   * =$server= - server object controlling connection
   * =$socket= - socket from accept()

Create and initialize an HttpCx object.

=cut

sub new {
    my $class = shift;
#    my( $server, $sock ) = @_;

    my $self = $class->SUPER::new( @_ );

    $self->_initOutput;

    return $self;
}

# ---++ ObjectMethod _initOutput()
# Initialize output parser
#
# Initializes (or resets) the output parser for a connection.

sub _initOutput {
    my $self = shift;

    my $ctx = $self->{ctx};

    $ctx->{txstate} = 'first';
    $ctx->{txlinebuf} = '';
    $ctx->{txheaders} = {};
    $ctx->{txlasthdr} = '';
    $ctx->{txbody} = '';
}

=pod

---++ ObjectMethod rawout( $new ) -> $old
Accessor for raw output state
   * =$new= - True to set raw output mode for connection; false to enable parser; omit to leave unchanged

Allows sending raw (unparsed and unbuffered) data over a connection.  Not recommended...

Returns old value

=cut

sub rawout {
    my $self = shift;

    my $ctx = $self->{ctx};

    my $old = $ctx->{txstate} eq 'rawout';
    if( @_ ) {
        $ctx->{txstate} = ( $_[0]? 'rawout' : 'first' );
    }
    return $old;
}

=pod

---++ ObjectMethod print( @list )
Write data to an HTTP connection
   * =@list= - Data to write.  Array elements are simply concatenated.

Parses data to extract headers and buffers entire message.  Any number of calls to print may be used to construct a response.

The first line written to a connection may be:
   * =Status: num text= - Set the response code and text for the response
   * =Content-Type: class/type= - Set the response content type for the response
   * =Location: 3xx url= - Set the response code and URL for a redirect response

If any of these are found, any additional headers will be parsed and extracted until a blank line (or an invalid header) is parsed.
Header names can be specified using either '-' or '_'.

Otherwise, the response status will default to  =200 OK=, the =Content-Type= to =text/plain=, and the data will go to the message
body.  Response headers can also be set using =rspheader=.  Server, Connection, Date and Content-Length headers will be 
automatically added and need not be generated by the application.

The resulting message can be assembled using =message()= or assembled and sent using =send()=.

=cut

sub print {
    my $self = shift;

    my $ctx = $self->{ctx};

    my $text = join( '', $ctx->{txlinebuf}, @_ );
    $ctx->{txlinebuf} = '';

    my $state = $ctx->{txstate};

    if( $state eq 'rawout' ) {
        return $self->SUPER::print( $text );
    }

    $text =~ s/\r+//gms;

    while( $text =~ /\n/ms ) {
        my $line;
        ( $line, $text ) = split( /\n/, $text, 2 );
        $text = '' unless( defined $text );

        if( $state eq 'first' ) {
            if( $line =~ /^Status:\s+((?:\d+)\s+.*)$/i ) {
                $ctx->{txheaders}{status} = $1;
                $ctx->{txstate} = $state = 'headers';
                next;
            }
            if( $line =~ m!^Content[-_]Type:\s+((?:[^/]+)/(?:[^/]+))$!i ) {
                $ctx->{txheaders}{content_type} = $1;
                $ctx->{txstate} = $state = 'headers';
                next;
            }
            if( $line =~ /^Location:\s+((?:\d+)\s+.*)$/ ) {
                $ctx->{txheaders}{status} = $1;
                $ctx->{txstate} = $state = 'headers';
                next;
            }
            $ctx->{txheaders}{status} = '200 OK' unless( $ctx->{txheaders}{status} );
            $ctx->{txheaders}{content_type} = 'text/plain' unless( $ctx->{txheaders}{content_type} );
            $ctx->{txstate} = $state = 'body';
        }
        if( $state eq 'headers' ) {
            if( $line =~ /^([^()<>\@,;:\\"\/\[\]?={} \t]+):\s*(.*)/ ) {
                my( $name, $value ) = ( lc( $ 1 ), $2 );
                $name =~ s/-/_/g;
                $ctx->{txheaders}{$name} = $value;
                $ctx->{txlasthdr} = lc $name;
                next;
            }
            # Continuation
            if( $line =~ /^\s+(.*)$/ && $ctx->{txlasthdr} ) {
                $self->{$ctx->{txlasthdr}} .= $1;
                next;
            }
            if( length( $line ) == 0 ) {
                $ctx->{txstate} = $state = 'body';
                next;
            }
            # Junk in headers, call it body text...
            $ctx->{txstate} = $state = 'body';
        }

        if( $state eq 'body' ) {
            $ctx->{txbody} .= $line . $CRLF;
            next;
        }
        die "CGI output parser confused: $state\n";
    }
    $ctx->{txlinebuf} = $text;

    return;
}

=pod

---++ ObjectMethod send()
Assemble and send response message from buffered state.

Re-initializes buffered state.

Response can't be retrieved after send()

=cut

sub send {
    my $self = shift;

    $self->SUPER::print( $self->message );
    $self->_initOutput;
}

=pod

---++ ObjectMethod message()
Assemble and fetch complete response message from buffered state

Adds or defaults the required response headers to the buffered response state.

Assembles the response message into wire format.

Does not modify message state (allowing multiple calls, e.g. for debugging.)

Returns response text

=cut

sub message {
    my $self = shift;

    my $ctx = $self->{ctx};

    my $body = $ctx->{txbody} . $ctx->{txlinebuf};

    my $hdrs = { %{$ctx->{txheaders}} };
    $hdrs->{status} ||= '200 OK';
    $hdrs->{content_type} ||= 'text/plain';
    $hdrs->{server} = 'TWikiDaemon/1.0';
    $hdrs->{date} = HTTP::Date::time2str;
    $hdrs->{connection} = 'close';
    $hdrs->{content_length} = length( $body ) unless( defined $hdrs->{content_length} );

    # status line must be first

    my $msg = "HTTP/1.0 " . delete( $hdrs->{status} ) . $CRLF;

    # Produce headers in random order - "should" use prefered order, but it shouldn't matter

    while( my( $n, $v ) = each %$hdrs ) {
        $n = join( '-', map { ucfirst } split( '_', $n ) );
        $n =~ s/^Www-/WWW-/;
        $n =~ s/Twiki/TWiki/g;

        $msg .= "$n: $v$CRLF";
    }
    $msg .= $CRLF;

    # Add the body

    $msg .= $body;

    return $msg;
}

=pod

---++ ObjectMethod cancelRsp()
Cancel a response message

Discards all buffered response state.

Used when an error is detected after generation of a response has started.

=cut

sub cancelRsp {
    my $self = shift;

    $self->_initOutput;
}

=pod

---++ ObjectMethod rspheader( @list )
Return/set headers for response
   * =@list= - array of (name,value) pairs of headers to add

Adds the specified header items to the buffered response message.  

Header names may be specified with '_' instead of '-' if desired, and the case of names is ignored.

If value is defined, it replaces the value of the named header item.

In array context, the previous value of each specified header item is returned in the order specified.

In scalar context, only the previous value of the first header item is returned.

=cut

sub rspheader {
    my $self = shift;

    my $ctx = $self->{ctx};

    my @old;

    while( @_ ) {
        my $name = shift;
        my $value = shift;

        $name =~ s/-/_/g;
        $name = lc $name;

        push @old, $ctx->{txheaders}{$name};
        $ctx->{txheaders}{$name} = $value if( defined $value );
    }

    return (wantarray? @old : $old[0]);
}

=pod

---++ ObjectMethod readLine( $line ) -> $maintainCx
Connection receive callback

Called with data from the connection.

Uses a state machine to parse the incoming message.  Headers are handled in line mode; body in binmode.

After the headers are parsed, the request is authenticated.

After the complete body has been received, if it is 'application/x-www-form-urlencoded', the form data is decoded.

The server =receive= callback is invoked with the complete message.

Returns 0 to drop the connection, 1 to maintain it.

=cut

sub readLine {
    my( $self, $line ) = @_;

    my $server = $self->server or return 0;

    my $ctx = $self->{ctx};

    # Parse method line: METHOD URI Protocol/V.V

    unless( exists $ctx->{rxmethod} ) {
	$line =~ m/^(\w+)\s+(\S+)(?:\s+(\S+))?\r?$/;
	$ctx->{rxmethod} = $1 || '';
	my $uri = $2 || '';
	$ctx->{rxprotocol} = $3 || '';

	$uri =~ /^([^?]*)?(?:\?([^#]*))?(?:#(.*))?$/ or return 0;
	$ctx->{rxfulluri} = $uri;
	$ctx->{rxuri} = $1 || '';
#	$ctx->{rxfrag} = $3 || ''; # Never sent by conforming browser
	$ctx->{rxquerystr} = $2 || '';
	$ctx->{rxquery} = parExtract( $2 || '' );

	return 0 unless( $ctx->{rxprotocol} =~ m!^HTTP/1\.(\d+)$! );
	return 1;
    }

    # Extract headers

  HEADER:
    {
	unless( exists $ctx->{rxbodylen} ) {
	    $line =~ s/[\l\s]+$//;
	    unless( length $line ) {
		# End of headers, extract cookies, check Content-Length for body
		foreach my $ch (@{$ctx->{rxheaders}{cookie}}, @{$ctx->{rxheaders}{cookie2}}) {
		    my $cookies;
		    eval {
			$cookies = CGI::Cookie->parse( $ch );
		    };
		    next unless $cookies;
		    foreach my $cookie (keys %$cookies) {
			$ctx->{rxcookies}{$cookie} = $cookies->{$cookie};
		    }
		}
		$ctx->{rxbody} = '';
		$ctx->{rxbodylen} = 0;
		if( my $cl = $ctx->{rxheaders}{content_length}[0] ) {
		    if( $cl !~ /^(\d+)$/ ) {
			$server->Error( $self, HTTP_BAD_REQUEST, "Invalid request" );
			return 0;
		    }
		    $self->binmode( 1 );
		    $ctx->{rxbodylen} = $1;
		    return 1 if( $1 );
		}
		last HEADER;
	    }
	    # Header
	    if( $line =~ /^([^()<>\@,;:\\"\/\[\]?={} \t]+):\s*(.*)/ ) {
		my( $name, $value ) = (lc( $1 ), $2 );
		$name =~ s/-/_/g;
		push @{$ctx->{rxheaders}{$name}}, $value;
		$ctx->{rxlasthdr} = lc $name;
		return 1;
	    }
	    # Continuation
	    if( $line =~ /^\s+(.*)$/ && $ctx->{rxlasthdr} ) {
		$ctx->{$ctx->{rxlasthdr}}[-1] .= $1;
		return 1;
	    }
	    # Unrecognizable junk
	    return 1;
	}
    }

    unless( $ctx->{rxauthenticated} ) {
	my $auth = $server->authenticate( $self );

	return 0 unless( $auth ); # Pipelineing would require reading & flushing body.  Malicous could be large...

	$ctx->{rxauthenticated} = 1;
    }

    # Buffer message body

    if( $ctx->{rxbodylen} > 0 ) {
	my $len = length $line;
	$len = $ctx->{rxbodylen} if( $len > $ctx->{rxbodylen} );
	$ctx->{rxbodylen} -= $len;
	$ctx->{rxbody} .= substr( $line, 0, $len, '' );

	$self->reinput( $line ) if( length $line ); # Return excess (could be next request)

	return 1 if( $ctx->{rxbodylen} > 0 );

	# End of body

	$self->binmode( 0 );

	my $ct = $ctx->{rxheaders}{content_type}[0];
	if( defined $ct && lc( $ct ) eq 'application/x-www-form-urlencoded' ) {
	    # Decode url-encoded form data

	    my $data = $ctx->{rxbody};
	    $data =~ s/\s+//gms;
	    $ctx->{rxformdata} = parExtract( $data );
	}
    }

    # Deliver message

    $server->receive( $self, $ctx->{rxmethod} );

    # Close connection

    return 0;
}

=pod

---++ ObjectMethod reqheader( $name, $value ) -> @old
Sets/returns value of request header
   * =$name= - header name
   * =$value= - Reference to replacement value(s) or a value to add to existing value list.  undef does not update value

If $value is defined, replaces the values or adds a value to the named header item.

In scalar context, returns the first value of the named header item.
In array context, returns all values of the named header item.  Values are in the order in which the headers were received.

=cut

sub reqheader {
    my( $self, $name, $value ) = @_;

    my $ctx = $self->{ctx};

    $name =~ s/-/_/g;
    $name = lc $name;

    my $old = $ctx->{rxheaders}{$name};

    if( defined $value ) {
	if( ref( $value ) ) {
	    $ctx->{rxheaders}{$name} = $value; # Replace with value or list
	} else {
	    push @{$ctx->{rxheaders}{$name}}, $value; # Add value
	}
    }

    return wantarray? @$old : $old->[0];
}

=pod

---++ ObjectMethod reqinfo() -> $info
Obtain request information

Returns a reference to a hash containing information about the current request.
   * =protocol= - The protocol identifier (E.g. HTTP/1.1)
   * =method= - The request method (E.g. GET)
   * =uri= - The requested URI (not including any query parameters)
   * =querystr= - The query string
   * =fulluri= - The complete URI as received
   * =scheme= - The URL's scheme (http or https)
   * =selfhost= - The server's hostname
   * =selfurl= - The full URL of the request
   * =cookies= - Reference to hash of cookies (name => value) provided in the request

N.B. Use param methods to get query and/or form parameter values

=cut

sub reqinfo {
    my $self = shift;

    my $ctx = $self->{ctx};

    my $selfhost = $self->sockhost( 1 ) || $TWiki::cfg{Tasks}{StatusAddr};

    return {
	    protocol => $ctx->{rxprotocol},
	    method   => $ctx->{rxmethod},
	    uri      => $ctx->{rxuri},
	    querystr => $ctx->{rxquerystr},
	    fullruri => $ctx->{rxfulluri},
	    scheme => (ref($self->{sock}) =~ /::SSL$/? 'https://' : 'http://'),
	    selfhost => $selfhost,
	    selfurl  => $selfhost . $ctx->{rxfulluri},
	    cookies  => $ctx->{rxcookies},
	   };
}

=pod

---++ ObjectMethod param( $name ) -> result
Return request parameter
   * =$name= - Requested parameter name.  If omitted, list of all parameter names.

Returns request parameters from form data or query string.  Form data has precedence.

If $name is not specified, returns a list of all parameter names (of both types).

Otherwise, in list context, returns all values of the named paramenter.  In scalar context, returns the *last* value of the
named parameter.

=cut

sub param {
    my $self = shift;

    my( $fpars, $qpars ) = @{$self->{ctx}}{'rxformdata','rxquery'};

    unless( @_ ) {
        my %keys = map { $_ => 1 } (keys %$fpars, keys %$qpars);
        return keys %keys;
    }
    my $name = $_[0];
    return _rparam( ((exists $self->{ctx}{rxformdata}{$name})? $self->{ctx}{rxformdata} : $self->{ctx}{rxquery}), @_ );
}

=pod

---++ ObjectMethod qparam( $name ) -> result
Return request parameter
   * =$name= - Requested parameter name.  If omitted, list of all parameter names.

Returns request parameters from query string.

If $name is not specified, returns a list of all query parameter names.

Otherwise, in list context, returns all values of the named paramenter.  In scalar context, returns the *last* value of the
named parameter.

=cut

sub qparam {
    my $self = shift;

    return _rparam( $self->{ctx}{rxquery}, @_ );
}

=pod

---++ ObjectMethod fparam( $name ) -> result
Return request parameter
   * =$name= - Requested parameter name.  If omitted, list of all parameter names.

Returns request parameters from form data.

If $name is not specified, returns a list of all form data names.

Otherwise, in list context, returns all values of the named paramenter.  In scalar context, returns the *last* value of the
named parameter.

=cut

sub fparam {
    my $self = shift;

    return _rparam( $self->{ctx}{rxformdata}, @_ );
}

# ---++ StaticMethod _rparam( $qpars, $name ) -> result
# private routine supporting param() routines
#   * =$qpars= - reference to hash of parameter ( name => value )
#   * =$name= - Requested parameter name.  If omitted, list of all parameter names.
#
# Returns request parameters from parameter data.
#
# If $name is not specified, returns a list of all form data names.
#
# Otherwise, if *caller* was called in list context, returns all values of the named paramenter.  In scalar context,
# returns the *last* value of the named parameter.

sub _rparam {
    my $qpars = shift;

    return keys %$qpars unless( @_ );

    my $name = shift;

    my $wantarray =  (caller(1))[5];

    return ($wantarray? () : undef) unless( exists $qpars->{$name} );
    my $pv = $qpars->{$name};

    return @$pv if( $wantarray );

    # Want a scalar but might have multiple values.  Return the last value.

    return $pv->[$#$pv];
}

=pod

---++ StaticMethod parExtrace( $data ) -> $hash
Extract a parameter hash from a url-encoded string
   * =$data= - url-encoded string

Create a parameter hash (name => [ val1, val2, ...]) from a url-encoded string

Default value to 1 if unspecified.  A name can occur more than once, in which case the values are saved in order.

Return reference to hash

=cut

sub parExtract {
    my $data = shift;

    my %params;
    foreach my $pv (split( /[&;]/, $data )) {
        my( $p, $v ) = split( '=', $pv, 2 );
        next unless( defined $p );

        $v = 1 unless( defined $v );
        ($p, $v) = (urlDecode( $p ), urlDecode( $v ));
        push @{$params{$p}}, $v;
    }
    return { %params };
}

=pod

---++ StaticMethod urlDecode( $encoded ) -> $decoded
Decode a url-encoded string
   * =$encoded= - encoded string

Url-encoded strings use '+' for spaces and %hh for other reserved characters.  However, even unreserved characters can
be percent-encoded.  Typical reserved characters include: % ! * ' ( ) ; : @ & = + $ , / ? # [ ]

For URIs, unreserved characters are m/[a-zA-Z0-9~.-]/; all others must be encoded.

Returns decoded string.

=cut

sub urlDecode {
    my $s = shift;
    $s =~ tr/+/ /;
    $s =~ s/%([a-fA-F0-9]{2})/chr(hex($1))/ge;
    return $s;
}

1;

__END__

This is an original work by Timothe Litt.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details, published at
http://www.gnu.org/copyleft/gpl.html
