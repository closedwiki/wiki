#!/usr/bin/perl
# -*- mode: CPerl; -*-

# Copyright (C) 2012 Timothe Litt <litt at acm dot org>
# License is at end of file.  
# Removal of Copyright and/or License prohibited.

# Dependency extractor.
# Recursively processes .pl/.pm files for require/use d modules and extracts
# their VERSION.  Generates DEPENDENCIES format output.
#
# Run from Component directory under trunk of an SVN checkout, or specify
# a base directory to scan and a TWiki core library to consult.
#
# --exclude is module prefix list to exclude (e.g. because known not to be versioned/interesting
# --Include is a list of other perl libraries to search
# --lib is the location of the TWiki core library.  Defaults to ../core/lib.
# --manifest is the location of the TWiki core MANIFEST; '-' to ignore.  Defaults to --lib/TWiki/Contrib/core/MANIFEST.
# --who lists modules that create each dependency
#
# Check output carefully; this script is clever, but not perfect.
# Notably, it assumes everything comes from CPAN and that everything is Required.


use warnings;
use strict;

use Cwd qw/realpath/;
use File::Basename;
use File::Find;
use Getopt::Long;
use Module::Extract::VERSION;
use Perl::Version;

my( $lib, @Include, $twikiMANIFEST, $who, @exclude );

GetOptions(
           "exclude=s" =>\@exclude,
           "Include=s", =>\@Include,
           "lib=s" => \$lib,
           "who-requires" => \$who,
          ) or exit (1 );

$lib = realpath( '../core/lib' ) unless( defined $lib );
chomp $lib;
unshift @INC, $lib;

$exclude[0] = 'TWiki::Tasks' if( !@exclude && realpath( '.' ) =~ /TasksPlugin$/ );

unshift @INC, @Include;

my %twikikit;
my %who;

$twikiMANIFEST = "$lib/TWiki/Contrib/core/MANIFEST" unless( defined $twikiMANIFEST );

# Modules shipped with TWiki:

unless( $twikiMANIFEST eq '-' ) {
    if( open( my $tman, '<', $twikiMANIFEST ) ) {
        while( <$tman> ) {
            chomp;
            s/[!#].*$//;
            s/^\s+//;
            s/\s+$//;
            next if( /^\s*$/ );
            my $tv;
            if( m,^\s*lib/CPAN/lib/(\S+\.pm), ) {
                $tv = $1;
                $twikikit{$tv}{file} = "$lib/CPAN/lib/$1";
                $twikikit{$tv}{ver} = Module::Extract::VERSION->parse_version_safely("$lib/CPAN/lib/$tv") || '0.0';
            } elsif( m,^\s*lib/(\S+\.pm), ) {
                $tv = $1;
                $twikikit{$tv}{file} = "$lib/$tv";
                $twikikit{$tv}{ver} = Module::Extract::VERSION->parse_version_safely("$lib/$tv") || '0.0';
            }
            if( defined $tv && $twikikit{$tv}{ver} eq '$Rev$' ) {
                my $r = realpath( $twikikit{$tv}{file} );
                $r = `svnversion $r`;
                if( $r && $r =~ /^(\d+)[MSP]?$/ ) {
                    $twikikit{$tv}{ver} = $1;
                }
            }
        }
        close $tman;
    } else {
        print( "Unable to read $twikiMANIFEST: $!.  Including all modules.\n" );
    }
}

# Modules from this component: traverse directory tree

$ARGV[0] = '.' unless( @ARGV );

find( { wanted => \&handle, no_chdir => 1, },  @ARGV );

my( %vers, %found );

sub handle {
    process( $File::Find::name, $File::Find::name );
}

# Recursive analysis:

sub process {
    my $parent = shift;
    $_ = shift;

    return if( /~$/ );

    return unless( -f $_ && ( /\.p[lm]$/ || -x $_ ) );

    my $fn = $_;
    $_ = basename $_;

    open( my $fh, '<', $fn ) or die "can't open $fn for $parent: $!\n";

    if( -x $fn ) {
        my $bang = <$fh>;
        unless( $bang && $bang =~ /#!.*perl\b/ ) {
            close $fh;
            return;
        }
    }

    my $pod;
    while( <$fh> ) {
        chomp;

        $pod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $pod;
        next if $pod || /^\s*#/;

        next unless( /^\s*(?:require|use)\s+[A-Za-z0-9_:]+/ );

        s/\s*(?:use|require)\s+//;
        s/^base\s+(?:qw.|["'])([A-Za-z0-9_:]+).*$/$1/;
        s/^([A-Za-z0-9_:]+).*$/$1/;
        /^(?:warnings|strict|attributes|autouse|blib|bytes|charnames|constant|diagnostics|fields|filetest|integer|less|lib|locale|open|overload|re|sigtrap|subs|vars)/ and next;

        next if ( /^\d/ ); # use VERSION

        my $pm = "${_}.pm";
        $pm =~ s,::,/,g;

        push @{$who{$_}}, $parent if( $who );

        next if( $found{$pm} );

        for my $lib (@INC ) { # doesn't include TWiki-shipped CPAN stuff.
            if( -f "$lib/$pm" ) {
                $found{$pm} = "$lib/$pm";
                last;
            }
        }
        unless( $found{$pm} || exists $twikikit{$pm} ) {
            print "Can't locate $pm for $parent in ", join( ', ', @INC ), "\n";
            next;
        }

        # We found in twikikit, must be OK

        next if( $found{$pm} && exists  $twikikit{$pm} && $found{$pm} eq "$lib/$pm" );

        my $excluded;
        for my $x (@exclude) {
            next unless( /^$x/ ); 
            $excluded = 1;
            last;
        }
        unless( $excluded ) {
            my $kv = Module::Extract::VERSION->parse_version_safely($found{$pm}) || '0.0';
            if( $kv eq '$Rev$' ) {
                my $r = realpath( $found{$pm} );
                $r = `svnversion $r`;
                if( $r && $r =~ /^(\d+)[MSP]?$/ ) {
                    $kv = $1
                }
            }
            $vers{$_} = $kv;

            if( exists $twikikit{$pm} ) {
                my $tv = $twikikit{$pm}{ver};
                eval {
                    $tv = Perl::Version->new( $tv ); # TWiki shipped
                    $kv = Perl::Version->new( $kv ); # This kit uses
                }; if( $@ ) {
                    print "Unable to compare versions of $_ for $parent; check TWiki distribution vs. kit.\n";
                    next;
                }
                if( ($tv <=> $kv) < 0 ) { # TWiki shipping old bits.
                    print "TWiki ships version $tv of $_, but $kv is required in $parent\n";
                }
                next;
            }
        }
        $_ = $found{$pm};
        if( /^\./ ) {
            process( $fn, $_ );
        }
    }
    close $fh;
}

for (sort keys %vers) {
    my $base = "$_,>=,$vers{$_},cpan,Required" ;
    if( $who ) {
        $base .= " by ";
        print $base, join( ",\n#" . (' ' x (length($base)-1)), 
                           sort @{$who{$_}} ), "\n";
    } else {
        print "$base\n";
    }
}

__END__

# This is an original work by Timothe Litt.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at
# http://www.gnu.org/copyleft/gpl.html
