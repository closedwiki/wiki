#!/usr/bin/perl -w
#
# TWiki Collaboration Platform, http://TWiki.org/
#
# Copyright (C) 1999-2003 Peter Thoeny, peter@thoeny.com
#
# For licensing info read license.txt file in the TWiki root.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details, published at 
# http://www.gnu.org/copyleft/gpl.html

# based upon the mailnotify script


# Set library paths in @INC, at compile time
BEGIN { unshift @INC, '.'; require 'setlib.cfg'; }

use strict;

use TWiki;
use TWiki::Net;
use TWiki::Func;
use TWiki::Plugins::NotificationPlugin;

our $dataDir;
our $oldestLastModifyTime;

our $debug = 1;
our $RE_stylefmt = qr/^(multi|srg|single)-?(html|text)?/i;

{
  package NotifyUser;

  # construct a user
  sub new
  {
    my ( $class ) = shift;
    my ( $userName, $groupName, $email ) = @_;

    my %self = ( 
		name => $userName,
		group => $groupName,
		email => $email,
		web => {},
		topic => {},
		regex => []
	       );

    # for user's requested mailnotify style
    TWiki::Prefs::initializeUserPrefs( 'Main.'. $userName );

    my $stylefmt = lc( TWiki::Prefs::getPreferencesValue( "NOTIFICATIONFORMAT" ) || 'single-text' );

    # correct for bogus value
    $stylefmt = 'single-text' unless $stylefmt =~ /$RE_stylefmt/;

    # split out style and format
    @self{'style', 'format'} = $stylefmt =~ /$RE_stylefmt/;

    $self{style} ||= 'single';
    $self{format} ||= 'text';

    bless \%self, $class;
  }

  sub name  { $_[0]->{name}  }
  sub email { $_[0]->{email} }
  sub web   { $_[0]->{web}   }
  sub topic { $_[0]->{topic} }
  sub regex { $_[0]->{regex} }
  sub style { $_[0]->{style} }
  sub format { $_[0]->{format} }

  sub addweb    { my $self = shift; $self->{web}{$_}++   foreach @_ }
  sub addtopic  { my $self = shift; $self->{topic}{$_}++ foreach @_ }
  sub addregex { my $self = shift; push @{$_[0]->{regex}}, @_ }

  sub wantsWeb  { exists $_[0]->{web}{$_[1]}   }
  sub wantsTopic{ exists $_[0]->{topic}{$_[1]} }

  sub wantsAnything
  {
    my $self = shift; 
    keys(%{$self->{web}}) + keys(%{$self->{topic}}) + @{$self->{regex}} ;
  }

  sub wantsRegex
  {
    my ( $self, $topic ) = @_;

    for my $regex ( @{$self->{regex}} )
    {
      my $pat = eval{ qr($regex) };
      next if $@;
      return 1 if $topic =~ /$pat/;
    }
    0;
  }

  # class method
  # return one or more users, depending upon if the wikiName is a group
  # $groupName will be == $userName if the the original wikiName was the user's.

  sub newUsers
  {
    my @wikiNames = @_;

    # if it's a group, split it into its constituents
    my @users;

    foreach my $wikiName ( @wikiNames )
    {
      if ( $wikiName =~ /Group$/ )
      {

	my @groupMembers = TWiki::Access::getUsersOfGroup( $wikiName );
	die( "membership in group $wikiName contains other groups; can't handle that!\n" )
	  if grep { /Group$/ } @groupMembers;


	foreach my $userName ( @groupMembers )
	{
	  my ( $email ) = TWiki::getEmailOfUser( $userName );
	  next unless $email;

	  push @users, NotifyUser->new( $userName, $wikiName, $email );
	}

      }
      else
      {
	my ( $email ) = TWiki::getEmailOfUser( $wikiName );
	next unless $email;

	push @users, NotifyUser->new( $wikiName, $wikiName, $email );
      }
    }

    @users;
  }

  # class method
  sub mergeUser
  {
    my ( $user1, $user2 ) = @_;

    $user1->{web} = { %{$user1->{web}}, %{$user2->{web}} };
    $user1->{topic} = { %{$user1->{topic}}, %{$user2->{topic}} };
    $user1->{regex} = [ @{$user1->{regex}}, @{$user2->{regex}} ];
  }

  # class method
  sub mergeUsers
  {
    my ( @users ) = @_;

    my %user;

    for my $user ( @users )
    {
      # existing user, merge
      if ( exists $user{ $user->{email}, $user->{name}} )
      {
	mergeUser( $user{$user->{email}, $user->{name} }, $user )
      }
      # new user
      else
      {
	$user{$user->{email}, $user->{name}} = $user;
      }
    }

    values %user;
  }
}

{
  package Topic;

  sub new
  {
    my $class = shift;

    my $self = bless {
		      fullName => $_[1] . '.' . $_[2],
		      html => '',
		      text => ''
		     }, $class;

    $self->render( @_ );

    $self;
  }

  sub fullName { $_[0]->{fullName} }
  sub html     { $_[0]->{html}     }
  sub text     { $_[0]->{text}     }

  sub render
  {
    my $self = shift;

    my ( $template, $webName, $topicName, $wikiuser, $time, $revision ) = @_;

    my $html = '';
    if ( defined $template->{html} ) {

      $html = $template->{html};

      $html =~ s/%TOPICNAME%/$topicName/g;
      $html =~ s/%WEBNAME%/$webName/g;
      $html =~ s/%AUTHOR%/$wikiuser/g;
      $html =~ s/%LOCKED%//g;
      $html =~ s/%TIME%/$time/g;
      $html =~ s/%REVISION%/1\.$revision/g;

      my $head = TWiki::Store::readFileHead( "$dataDir\/$webName\/$topicName.txt", 16 );

      $head = TWiki::makeTopicSummary( $head, $topicName, $webName );
      $html =~ s/%TEXTHEAD%/$head/g;
    }

    $self->{html} = $html;

    # always do plain text version

    # URL-encode topic names for use of I18N topic names in plain text
    my $webNameEnc = TWiki::handleUrlEncode( $webName );
    my $topicNameEnc = TWiki::handleUrlEncode( $topicName );
    my $url = TWiki::handleUrlEncode(TWiki::Func::getViewUrl($webName, $topicName));

    my $text = $template->{text};

    $text =~ s/%TOPICNAME%/$topicName/g;
    $text =~ s/%WEBNAME%/$webName/g;
    $text =~ s/%AUTHOR%/$wikiuser/g;
    $text =~ s/%LOCKED%//g;
    $text =~ s/%TIME%/$time/g;
    $text =~ s/%REVISION%/1\.$revision/g;
    $text =~ s/%URL%/$url/g;

    $text =~ s/Main\.//go;

    $self->{text} = $text;
  }


}

{
  package TopicList;

  sub new
  {
    my $class = shift;

    my %self = ( saved => {},
		 topics => [] );

    bless \%self, $class;
  }

  sub text { join( '', map { $_->text } @{$_[0]->{topics}} ) }
  sub html { join( '', map { $_->html } @{$_[0]->{topics}} ) }

  sub add
  {
    my ( $self, $topic ) = @_;

    push @{$self->{topics}}, $topic
      unless exists $self->{saved}{$topic->fullName};

    $self->{saved}{$topic->fullName}++;
  }

}

{
  package WebTopicList;

  sub new
  {
    my $class = shift;

    my ( $webName, $template ) = @_;

    my %self = ( name => $webName,
		 html => '',
		 topics => TopicList->new(),
	       );

    if ( defined $template->{html} )
    {
      ( $self{html} = $template->{html} )  =~ s/%WEBNAME%/$webName/g;
    }

    ( $self{text} = $template->{text} )  =~ s/%WEBNAME%/$webName/g;


    bless \%self, $class;
  }

  sub name { $_[0]->{name} }
  sub text { $_[0]->{text} . $_[0]->{topics}->text }
  sub html { $_[0]->{html} . $_[0]->{topics}->html }

  sub add { my $self = shift; $self->{topics}->add( @_ ) }

}


# the more, the merrier
$debug = (grep { $_ eq '-d' } @ARGV) || 1;
$debug = 0 if grep { $_ eq '-q' } @ARGV;

if ( $debug > 1 )
{
  require Data::Dumper;
}

main();

sub main
{
  TWiki::basicInitialize();

  # got to do this or all hell breaks loose.
  TWiki::initialize( "/Main", "nobody" );

  $dataDir = TWiki::Func::getDataDir();

  TWiki::Func::writeDebug( "START REGULAR NOTIFICATIONS" );
  TWiki::Func::writeDebug( "===========================" );
  $debug && warn "TWiki mail notification\n";
  $debug && warn "- to suppress all normal output: mailnotify -q\n";

  # get a list of the available Webs
  my @weblist = getWeblist( );

  my ( @users, %notify );

  my @plugin_users =  getNotificationPluginUsers();

  $debug > 2 && warn Data::Dumper->Dump([\@plugin_users], [ '*PluginUsers' ]);

  my @webNotify_users =  getAllWebNotifyUsers( \@weblist );

  $debug > 2 && warn Data::Dumper->Dump([\@webNotify_users], [ '*WebNotifyUsers' ]);

  @users = grep { $_->wantsAnything } NotifyUser::mergeUsers( @plugin_users, @webNotify_users );

  $debug > 2 && warn Data::Dumper->Dump([\@users], [ '*Users' ]);


  my $allChanges = getChanges( @weblist );

  foreach my $user ( @users ) {
    processUser( $user, $allChanges )
  }

  TWiki::Func::writeDebug( "FINISH REGULAR NOTIFICATIONS" );
  TWiki::Func::writeDebug( "============================" );
  $debug && warn "End TWiki mail notification\n";

}

sub processUser
{
  my ( $user, $allChanges ) = @_;

  $debug && warn "- Start TWiki.", $user->name, "\n";

  my ( $topic ) =  
    TWiki::initialize( "/Main", $user->name );

  my %template = getTemplates( $user->style );


  # try to keep everybody happy. we support:
  #  SRG (Single Email, Request Grouping):
  #    original mailnotify-np
  #      single email. output is grouped by how the notification was requested:
  #           a. WebNotify (both via plugin and WebNotify topic)
  #           b. TopicNotify
  #           c. RegexNotify
  #      Topics may be duplicated between the groups
  #
  #  Multi:
  #    original TWiki mailnotify.  one email is sent per Web
  #
  #  Single:
  #    single email.  grouped by web.
  #
  #  SingleReqGrp (a), Multi, and Single require the same sort of data organization.
  #  SingleReqGrp (b) and (c) are, well, different.

  my %WebNotify;
  my $RegexNotify = TopicList->new;
  my $TopicNotify = TopicList->new;

  my $count = 0;

  foreach my $change ( @$allChanges ) {

    $debug > 1 && warn Data::Dumper->Dump( [$change], ['Change'] );

    my ( $webName, $topicName, $userName, $changeTime, $revision ) = @$change;

    $WebNotify{$webName} ||= WebTopicList->new( $webName, $template{web} );

    my $fullTopicName = "$webName.$topicName";

    # try to optimize this just a bit
    if ( $user->style eq 'srg' )
    {
      my $gotWeb    = $user->wantsWeb($webName);
      my $gotTopic  = $user->wantsTopic($fullTopicName);
      my $gotRegex  = $user->wantsRegex( $fullTopicName);

      if ( $gotWeb || $gotTopic || $gotRegex )
      {
	my $topic = Topic->new( $template{topic}, @$change );


	$WebNotify{$webName}->add( $topic ) if $gotWeb;
	$TopicNotify->add( $topic )         if $gotTopic;
	$RegexNotify->add( $topic )         if $gotRegex;

	$count++;
      }
    }

    # short circuit for speed
    elsif ( $user->wantsWeb($webName) ||
	    $user->wantsTopic($fullTopicName) ||
	    $user->wantsRegex( $fullTopicName) )
    {
      $WebNotify{$webName}->add( Topic->new( $template{topic}, @$change ) );
      $count++;
    }

  }

  emailUser( $user, \%template, \%WebNotify, $RegexNotify, $TopicNotify )
    if $count > 0;

  $debug && warn "- End TWiki.", $user->name, "\n";
}

sub emailUser
{
  my ( $user, $template, $WebNotify, $RegexNotify, $TopicNotify ) = @_;


  my $email_tpl = join('-', 'mailnotify', $user->style, $user->format );

  # reset to the default mailnotify template if multi & html
  $email_tpl = 'mailnotify' if 'multi' eq $user->style && 'html' eq $user->format;


  my $email = TWiki::Store::readTemplate( $email_tpl, TWiki::Prefs::getPreferencesValue( "SKIN" ) );
  my $from  = TWiki::Prefs::getPreferencesValue("WIKIWEBMASTER");

  # one email per web
  if ( 'multi' eq $user->style )
  {
    my $email_s = $email;
    foreach my $web ( values %$WebNotify )
    {
      $email = $email_s;

      my $topiclist = $template->{before}{text} . $web->text . $template->{after}{text};

      my $emailbody = 
	'text' eq $user->format ? '' :
	  $template->{before}{html} . $web->html . $template->{after}{html};

      postProcessEmail( $from, $user, $web->name, $email, $topiclist, $emailbody );
    }
  }


  # one email
  elsif ( 'single' eq $user->style )
  {
    my $topiclist = join('', 
			 $template->{before}{text},
			 ( map { $_->text } values %$WebNotify),
			 $template->{after}{text} );

    my $emailbody = 
	'text' eq $user->format ? '' :
	  join('', 
	       $template->{before}{html},
	       ( map { $_->html } values %$WebNotify),
	       $template->{after}{html} );


    postProcessEmail( $from, $user, 'Main', $email, $topiclist, $emailbody );
  }

  # mixed
  elsif ( 'srg' eq $user->style )
  {
    my $topiclist = join('', 
			 $template->{before}{text},
			 ( map { $_->text } values %$WebNotify),
			 $template->{after}{text} );

    my $topictext = $TopicNotify->text;
    $topiclist =~ s/%TOPICLIST%/$topictext/gi;
    my $regextext = $RegexNotify->text;
    $topiclist =~ s/%REGEXLIST%/$regextext/gi;


    my $emailbody = 
	'text' eq $user->format ? '' :
	  join('', 
	       $template->{before}{html},
	       ( map { $_->html } values %$WebNotify),
	       $template->{after}{html} );

    my $topichtml = $TopicNotify->html;
    $emailbody =~ s/%TOPICLIST%/$topichtml/gi;
    my $regexhtml = $RegexNotify->html;
    $emailbody =~ s/%REGEXLIST%/$regexhtml/gi;

    postProcessEmail( $from, $user, 'Main', $email, $topiclist, $emailbody );
  }

  else
  {
    die( "internal error: unknown style (", $user->style, ") for user ", $user->name, "\n" );
  }

}

sub postProcessEmail
{
  my ( $from, $user, $webName, $email, $topiclist, $emailbody ) = @_;

  my $userName  = $user->name;
  my $userEmail = $user->email;

  $emailbody = TWiki::Func::renderText( TWiki::Func::expandCommonVariables( $emailbody, 'WebHome', 'Main' ) );

  $email =~ s/%EMAILBODY%/$emailbody/go;
  $email =~ s/%TOPICLIST%/$topiclist/goi;


  $email =~ s/%EMAILFROM%/$from/go;
  $email =~ s/%EMAILTO%/$userEmail/g;
  $email =~ s/%LASTDATE%/$oldestLastModifyTime/geo;
  $email =~ s/%WIKIUSER%/$userName/g;

  $email = TWiki::Func::expandCommonVariables( $email, 'WebHome', 'Main' );



  # change absolute addresses to relative ones & do some cleanup
  my $scriptUrlPath = TWiki::Func::getScriptUrlPath();
  $email =~ s/(href=\")$scriptUrlPath/$1..\/../goi;
  $email =~ s/(action=\")$scriptUrlPath/$1..\/../goi;
  $email =~ s/( ?) *<\/?(nop|noautolink)\/?>\n?/$1/gois; # remove <nop> and <noautolink> tags

  if ( $TWiki::doRemoveImgInMailnotify ) {
    # change images to [alt] text if there, else remove image
    $email =~ s/<img src=.*?alt=\"([^\"]+)[^>]*>/[$1]/goi;
    $email =~ s/<img src=.*?[^>]>//goi;
  }



  $debug && warn "- Sending mail notification to ", $user->name, "\n";
  TWiki::Func::writeDebug( "MAIL SENT TO " . $user->name . "..." );

  $debug > 2 && warn $email;

  my $error = TWiki::Net::sendEmail( $email );
  if ( $error ) {
    TWiki::Func::writeDebug( "ERROR IN SENDING MAIL - $error" );
    warn "* $error\n";
  }
}


sub getNotificationPluginUsers
{
  my @users = NotifyUser::newUsers( TWiki::Plugins::NotificationPlugin::getUsers() );

  # notifications are keyed off of email addresses, as those are guaranteed to be unique.
  # it is possible that a user will have multiple email addresses.

  foreach my $user ( @users ) {

    my $wikiName  = $user->name;

    $user->addweb(TWiki::Plugins::NotificationPlugin::getNotificationsOfUser( $wikiName, 4 ) );

    $user->addtopic(TWiki::Plugins::NotificationPlugin::getNotificationsOfUser( $wikiName, 3 ) );

    $user->addregex( TWiki::Plugins::NotificationPlugin::getNotificationsOfUser( $wikiName, 5 ) );

  }


  @users;
}

sub getAllWebNotifyUsers
{
  my ( $weblist ) = @_;

  my @users;
  for my $webName ( @$weblist )
  {
    my @wusers = getWebNotifyUsers($webName);
    $_->addweb( $webName ) foreach @wusers;
    push @users, @wusers;
  }

  @users;
}

sub getWeblist
{
  opendir( DIR, "$dataDir" ) or die "could not open $dataDir";
  my @weblist = grep !/^\.\.?$/, readdir DIR;
  closedir DIR;

  return @weblist;
}

# here we grab all of the templates.  There are two classes of
# templates.  The first is used to render Changes.  The second is the
# email template.  Templates are a function of the notification style.

# Both come in HTML and text versions.  The text Change templates
# are always used, as the HTML email has both text and HTML.

sub getTemplates
{
  my ( $style ) = @_;

  return
    'single' eq $style ? getSingleTemplates() :
    'multi'  eq $style ? getMultiTemplates() :
    'srg'    eq $style ? getSRGTemplates() :

      die( "internal error: unexpected user style value: $style\n" );
}

sub getTemplate
{
  my ( $template ) = @_;

  my ( $topic, $webName, $dummy, $userName, $dataDir) = 
    TWiki::initialize( "/Main", "nobody" );

  my $skin = TWiki::Prefs::getPreferencesValue( "SKIN" );
  my $tmpl = TWiki::Store::readTemplate( $template, $skin );

  $tmpl =~ s/\%META{.*?}\%//go;  # remove %META{"parent"}%

  return $tmpl;
}

sub getSingleTemplates
{
  my %html;
  my %text;

  @html{qw/ before web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes-single-html' ) );

  @text{qw/ before web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes-single-text' ) );

  { map { $_ => { html => $html{$_} || '', text => $text{$_} || '' } } qw/ before web topic after / }
}

sub getMultiTemplates
{
  my %html;
  my %text;

  @html{qw/ web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes' ) );

  @text{qw/ web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes-multi-text' ) );


  { map { $_ => { html => $html{$_} || '', text => $text{$_} || '' } } qw/ before web topic after / }
}

sub getSRGTemplates
{
  my %html;
  my %text;

  @html{qw/ before web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes-srg-html' ) );


  @text{qw/ before web topic after/ } =
    split( /%REPEAT%/, getTemplate( 'changes-srg-text' ) );

  { map { $_ => { html => $html{$_} || '', text => $text{$_} || '' } } qw/ before web topic after / }
}


sub getChanges
{
  my ( @weblist ) = @_;

  my @allChanges;
  my $oldestLastModify;

  foreach my $webName ( @weblist ) {

    # Only process webs with normal names, i.e. not starting with '_'
    next unless -d "$dataDir/$webName" && TWiki::isWebName( $webName );

    my $changes= TWiki::Store::readFile( "$dataDir/$webName/.changes" );
    my $lastmodify = TWiki::Store::readFile( "$dataDir/$webName/.mailnotify" ) 
      || "0";

    $oldestLastModify = $lastmodify unless defined $oldestLastModify;
    $oldestLastModify = $lastmodify if $oldestLastModify > $lastmodify;


    $debug > 2 && warn "Web $webName: lastmodify = $lastmodify\n";


    my $currmodify = 0;
    my %exclude;

    foreach my $change ( reverse split( /\n/, $changes ) ) {

      $debug > 2 && warn "$change\n";

      # Parse lines from .changes:
      # <topic>	<user>		<change time>	<revision>
      # WebHome	FredBloggs	1014591347	21

      my ( $topicName, $userName, $changeTime, $revision ) = split( /\t/, $change );
      next if $exclude{ "$webName.$topicName" }
	|| ! TWiki::Store::topicExists( $webName, $topicName );

      $currmodify = $changeTime if ( $changeTime > $currmodify );

      last if ( $changeTime <= $lastmodify );

      $changeTime = TWiki::formatTime( $changeTime, 'iso', 'gmtime' );
      $userName   = TWiki::userToWikiName( $userName, 1 );

      $revision = $revision > 1 ? "r1.$revision": "<b>NEW</b>"
	if $revision;

      push @allChanges, [$webName, $topicName, $userName, $changeTime, $revision ];
      $exclude{"$webName.$topicName"}++;
    }

    # remove obsolete .lock files
    TWiki::Store::removeObsoleteTopicLocks( $webName );

    # save date of the last modification
    TWiki::Store::saveFile( "$dataDir/$webName/.mailnotify", $currmodify );
  }

  $debug > 1 && warn Data::Dumper->Dump([\@allChanges], [ '*allChanges' ]);

  $oldestLastModifyTime = TWiki::Func::formatTime($oldestLastModify, 'iso', 'gmtime');

  return \@allChanges;
}





# stolen from TWiki::getEmailNotifyList and mangled.  this is really a
# horrible thing to do, but we need the users' names, as well as the
# email addresses.  this returns the same sort of list as getUserEmail(), above.

sub getWebNotifyUsers
{
  my( $web, $topicname ) = @_;

  $topicname = $TWiki::notifyTopicname unless $topicname;
  return() unless TWiki::Store::topicExists( $web, $topicname );

  # Allow %MAINWEB% as well as 'Main' in front of users/groups -
  # non-capturing regex.
  my $mainWebPattern = qr/(?:$TWiki::mainWebname|%MAINWEB%)/;

  my @users;
  my %seen;			# Incremented when email address is seen
  foreach ( split ( /\n/, TWiki::Store::readWebTopic( $web, $topicname ) ) ) {
    if ( /^\s+\*\s(?:$mainWebPattern\.)?($TWiki::regex{wikiWordRegex})\s+\-\s+($TWiki::regex{emailAddrRegex})/o ) {
      # Got full form:   * Main.WikiName - email@domain
      # (the 'Main.' part is optional, non-capturing)
      if ( $1 ne 'TWikiGuest' ) {

	# Add email address to list if non-guest and non-duplicate
	# we don't split up Groups here, as an explicit email address was given.
	push @users, NotifyUser->new( $1, $1, $2);
      }
    } elsif ( /^\s+\*\s(?:$mainWebPattern\.)?($TWiki::regex{wikiWordRegex})\s*$/o ) { 

      # Got short form:   * Main.WikiName
      # (the 'Main.' part is optional, non-capturing)
      my $wikiName = $1;

      # worry about groups
      push @users, NotifyUser::newUsers( $wikiName );
    }
  }

  return @users;
}
